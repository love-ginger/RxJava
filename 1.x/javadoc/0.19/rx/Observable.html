<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Mon Jul 14 09:19:56 PDT 2014 -->
<TITLE>
Observable (RxJava Javadoc 0.19)
</TITLE>

<META NAME="date" CONTENT="2014-07-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../javadocStyleSheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Observable (RxJava Javadoc 0.19)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<a href='https://github.com/Netflix/RxJava'><img width='408' height='73' border='0' align='left' src='http://netflix.github.com/RxJava/images/NetflixOSS-banner.jpg'></a><h2 class='title' style='padding-top:57px;padding-left:415px;margin:0px'>RxJava: Reactive Extensions for the JVM</h2><HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../rx/Notification.Kind.html" title="enum in rx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?rx/Observable.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Observable.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
rx</FONT>
<BR>
Class Observable&lt;T&gt;</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>rx.Observable&lt;T&gt;</B>
</PRE>
<DL>
<DT><DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items emitted by the Observable</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>, <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>, <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Observable&lt;T&gt;</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The Observable class that implements the Reactive Pattern.
 <p>
 This class provides methods for subscribing to the Observable as well as delegate methods to the various
 Observers.
 <p>
 The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 <p>
 <img width="640" height="301" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/legend.png">
 <p>
 For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx">Observable.OnSubscribe</A>&lt;<A HREF="../rx/Observable.OnSubscribe.html" title="type parameter in Observable.OnSubscribe">T</A>&gt;</B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoked when Obserable.subscribe is called.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.OnSubscribeFunc.html" title="interface in rx">Observable.OnSubscribeFunc</A>&lt;<A HREF="../rx/Observable.OnSubscribeFunc.html" title="type parameter in Observable.OnSubscribeFunc">T</A>&gt;</B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use <A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><CODE>Observable.OnSubscribe</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.Operator.html" title="interface in rx">Observable.Operator</A>&lt;<A HREF="../rx/Observable.Operator.html" title="type parameter in Observable.Operator">R</A>,<A HREF="../rx/Observable.Operator.html" title="type parameter in Observable.Operator">T</A>&gt;</B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operator function for lifting into an Observable.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#Observable(rx.Observable.OnSubscribe)">Observable</A></B>(<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx">Observable.OnSubscribe</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an Observable with a Function to execute when it is subscribed to.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#all(rx.functions.Func1)">all</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a Boolean that indicates whether all of the items emitted by the source
 Observable satisfy a condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(java.lang.Iterable)">amb</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sources)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mirrors the one Observable in an Iterable of several Observables that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given two Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given three Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given four Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given five Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given six Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given seven Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given eight Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">amb</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o8,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given nine Observables, mirrors the one that first emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#ambWith(rx.Observable)">ambWith</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mirrors the first Observable (current or provided) that emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#asObservable()">asObservable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disguises a object of an Observable subclass as a simple Observable object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(rx.functions.Func0)">buffer</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;bufferClosingSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(int)">buffer</A></B>(int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(int, int)">buffer</A></B>(int&nbsp;count,
       int&nbsp;skip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit)">buffer</A></B>(long&nbsp;timespan,
       long&nbsp;timeshift,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)">buffer</A></B>(long&nbsp;timespan,
       long&nbsp;timeshift,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit)">buffer</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int)">buffer</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)">buffer</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       int&nbsp;count,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, rx.Scheduler)">buffer</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TOpening,TClosing&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(rx.Observable, rx.functions.Func1)">buffer</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TOpening&gt;&nbsp;bufferOpenings,
       <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super TOpening,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;bufferClosingSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits buffers of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;B&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(rx.Observable)">buffer</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;B&gt;&nbsp;boundary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;B&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#buffer(rx.Observable, int)">buffer</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;B&gt;&nbsp;boundary,
       int&nbsp;initialCapacity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#cache()">cache</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Caches the emissions from the source Observable and replays them in order to any subsequent Subscribers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#cast(java.lang.Class)">cast</A></B>(java.lang.Class&lt;R&gt;&nbsp;klass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by the source Observable, converted to the specified
 type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#collect(R, rx.functions.Action2)">collect</A></B>(R&nbsp;state,
        <A HREF="../rx/functions/Action2.html" title="interface in rx.functions">Action2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;collector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collects items emitted by the source Observable into a single mutable data structure and returns an
 Observable that emits this structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(java.util.List, rx.functions.FuncN)">combineLatest</A></B>(java.util.List&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sources,
              <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines a list of source Observables by emitting an item that aggregates the latest values of each of
 the source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.functions.Func2)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T1,? super T2,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines two source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from either of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.functions.Func3)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/functions/Func3.html" title="interface in rx.functions">Func3</A>&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines three source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func4)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/functions/Func4.html" title="interface in rx.functions">Func4</A>&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines four source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func5)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
              <A HREF="../rx/functions/Func5.html" title="interface in rx.functions">Func5</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines five source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func6)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
              <A HREF="../rx/functions/Func6.html" title="interface in rx.functions">Func6</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines six source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func7)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
              <A HREF="../rx/functions/Func7.html" title="interface in rx.functions">Func7</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines seven source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,T8,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func8)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
              <A HREF="../rx/functions/Func8.html" title="interface in rx.functions">Func8</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines eight source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func9)">combineLatest</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T9&gt;&nbsp;o9,
              <A HREF="../rx/functions/Func9.html" title="interface in rx.functions">Func9</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R&gt;&nbsp;combineFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines nine source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observables)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by each of the Observables emitted by the source
 Observable, one after the other, without interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by two Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by three Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by four Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by five Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by six Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by seven Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by eight Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by nine Observables, one after the other, without
 interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concatMap(rx.functions.Func1)">concatMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new Observable that emits items resulting from applying a function that you supply to each item
 emitted by the source Observable, where that function returns an Observable, and then emitting the items
 that result from concatinating those resulting Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concatWith(rx.Observable)">concatWith</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted from the current Observable, then the next, one after
 the other, without interleaving them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#contains(java.lang.Object)">contains</A></B>(java.lang.Object&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a Boolean that indicates whether the source Observable emitted a
 specified item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#count()">count</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the count of the total number of items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#create(rx.Observable.OnSubscribe)">create</A></B>(<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx">Observable.OnSubscribe</A>&lt;T&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that will execute the specified function when a <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> subscribes to
 it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#create(rx.Observable.OnSubscribeFunc)">create</A></B>(<A HREF="../rx/Observable.OnSubscribeFunc.html" title="interface in rx">Observable.OnSubscribeFunc</A>&lt;T&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use <A HREF="../rx/Observable.html#create(rx.Observable.OnSubscribe)"><CODE>Observable.create(OnSubscribe)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#debounce(rx.functions.Func1)">debounce</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;debounceSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by another item within a computed debounce duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit)">debounce</A></B>(long&nbsp;timeout,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit, rx.Scheduler)">debounce</A></B>(long&nbsp;timeout,
         java.util.concurrent.TimeUnit&nbsp;unit,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires on a specified
 Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#defaultIfEmpty(T)">defaultIfEmpty</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by the source Observable or a specified default item
 if the source Observable is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#defer(rx.functions.Func0)">defer</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observableFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that calls an Observable factory to create an Observable for each new Observer
 that subscribes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delay(rx.functions.Func0, rx.functions.Func1)">delay</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;subscriptionDelay,
      <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;itemDelay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that delays the subscription to and emissions from the souce Observable via another
 Observable on a per-item basis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delay(rx.functions.Func1)">delay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;itemDelay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that delays the emissions of the source Observable via another Observable on a
 per-item basis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delay(long, java.util.concurrent.TimeUnit)">delay</A></B>(long&nbsp;delay,
      java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delay(long, java.util.concurrent.TimeUnit, rx.Scheduler)">delay</A></B>(long&nbsp;delay,
      java.util.concurrent.TimeUnit&nbsp;unit,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delaySubscription(long, java.util.concurrent.TimeUnit)">delaySubscription</A></B>(long&nbsp;delay,
                  java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that delays the subscription to the source Observable by a given amount of time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#delaySubscription(long, java.util.concurrent.TimeUnit, rx.Scheduler)">delaySubscription</A></B>(long&nbsp;delay,
                  java.util.concurrent.TimeUnit&nbsp;unit,
                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that delays the subscription to the source Observable by a given amount of time,
 both waiting and subscribing on a given Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T2&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#dematerialize()">dematerialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that reverses the effect of <A HREF="../rx/Observable.html#materialize()"><CODE>materialize</CODE></A> by transforming the
 <A HREF="../rx/Notification.html" title="class in rx"><CODE>Notification</CODE></A> objects emitted by the source Observable into the items or notifications they
 represent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#distinct()">distinct</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits all items emitted by the source Observable that are distinct.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#distinct(rx.functions.Func1)">distinct</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends U&gt;&nbsp;keySelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits all items emitted by the source Observable that are distinct according
 to a key selector function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#distinctUntilChanged()">distinctUntilChanged</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#distinctUntilChanged(rx.functions.Func1)">distinctUntilChanged</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends U&gt;&nbsp;keySelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors, according to a key selector function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnCompleted(rx.functions.Action0)">doOnCompleted</A></B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onCompleted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnEach(rx.functions.Action1)">doOnEach</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;onNotification)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it invokes an action for each item it emits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnEach(rx.Observer)">doOnEach</A></B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it notifies an Observer for each item it emits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnError(rx.functions.Action1)">doOnError</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it invokes an action if it calls <code>onError</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnNext(rx.functions.Action1)">doOnNext</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it invokes an action when it calls <code>onNext</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#doOnTerminate(rx.functions.Action0)">doOnTerminate</A></B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onTerminate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code> or
 <code>onError</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#elementAt(int)">elementAt</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
 source Observbable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#elementAtOrDefault(int, T)">elementAtOrDefault</A></B>(int&nbsp;index,
                   <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
 source Observable, or a default item if that index is out of range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#empty()">empty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> and immediately invokes its
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#empty(rx.Scheduler)">empty</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> and immediately invokes its
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method on the specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#error(java.lang.Throwable)">error</A></B>(java.lang.Throwable&nbsp;exception)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that invokes an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method when the
 Observer subscribes to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#error(java.lang.Throwable, rx.Scheduler)">error</A></B>(java.lang.Throwable&nbsp;exception,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that invokes an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method on the
 specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#exists(rx.functions.Func1)">exists</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits <code>true</code> if any item emitted by the source Observable satisfies a
 specified condition, otherwise <code>false</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#filter(rx.functions.Func1)">filter</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters items emitted by an Observable by only emitting those that satisfy a specified predicate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#finallyDo(rx.functions.Action0)">finallyDo</A></B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;action)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an <A HREF="../rx/functions/Action0.html" title="interface in rx.functions"><CODE>Action0</CODE></A> to be called when this Observable invokes either
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> or <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#first()">first</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the very first item emitted by the source Observable, or notifies
 of an <code>NoSuchElementException</code> if the source Observable is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#first(rx.functions.Func1)">first</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or notifies of an <code>NoSuchElementException</code> if no such items are emitted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#firstOrDefault(T)">firstOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the very first item emitted by the source Observable, or a default
 item if the source Observable completes without emitting anything.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#firstOrDefault(T, rx.functions.Func1)">firstOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
               <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or a default item if the source Observable emits no such items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#flatMap(rx.functions.Func1)">flatMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items based on applying a function that you supply to each item emitted
 by the source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#forEach(rx.functions.Action1)">forEach</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#forEach(rx.functions.Action1, rx.functions.Action1)">forEach</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
        <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element and error events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#forEach(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0)">forEach</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
        <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError,
        <A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onComplete)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element and the terminal events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.util.concurrent.Future)">from</A></B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <CODE>Future</CODE> into an Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit)">from</A></B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future,
     long&nbsp;timeout,
     java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <CODE>Future</CODE> into an Observable, with a timeout on the Future.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.util.concurrent.Future, rx.Scheduler)">from</A></B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a <CODE>Future</CODE>, operating on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, into an Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.lang.Iterable)">from</A></B>(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an <CODE>Iterable</CODE> sequence into an Observable that emits the items in the sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.lang.Iterable, rx.Scheduler)">from</A></B>(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an <CODE>Iterable</CODE> sequence into an Observable that operates on the specified Scheduler,
 emitting each item from the sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T...)">from</A></B>(T...&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Array into an Observable that emits the items in the Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T)">from</A></B>(T&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an item into an Observable that emits that item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T[], rx.Scheduler)">from</A></B>(T[]&nbsp;items,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Array into an Observable that emits the items in the Array on a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts two items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts three items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts four items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts five items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5,
     T&nbsp;t6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts six items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5,
     T&nbsp;t6,
     T&nbsp;t7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts seven items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5,
     T&nbsp;t6,
     T&nbsp;t7,
     T&nbsp;t8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts eight items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5,
     T&nbsp;t6,
     T&nbsp;t7,
     T&nbsp;t8,
     T&nbsp;t9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts nine items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T, T, T, T, T, T, T, T, T, T)">from</A></B>(T&nbsp;t1,
     T&nbsp;t2,
     T&nbsp;t3,
     T&nbsp;t4,
     T&nbsp;t5,
     T&nbsp;t6,
     T&nbsp;t7,
     T&nbsp;t8,
     T&nbsp;t9,
     T&nbsp;t10)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts ten items into an Observable that emits those items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#groupBy(rx.functions.Func1)">groupBy</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Groups the items emitted by an <code>Observable</code> according to a specified criterion, and emits these
 grouped items as <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s, one <code>GroupedObservable</code> per group.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TKey,TDuration&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#groupByUntil(rx.functions.Func1, rx.functions.Func1)">groupByUntil</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TKey&gt;&nbsp;keySelector,
             <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TDuration&gt;&gt;&nbsp;durationSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Groups the items emitted by an <code>Observable</code> according to a specified key selector function until
 the duration <code>Observable</code> expires for the key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TKey,TValue,TDuration&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,TValue&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#groupByUntil(rx.functions.Func1, rx.functions.Func1, rx.functions.Func1)">groupByUntil</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TKey&gt;&nbsp;keySelector,
             <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TValue&gt;&nbsp;valueSelector,
             <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,TValue&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TDuration&gt;&gt;&nbsp;durationSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Groups the items emitted by an <code>Observable</code> (transformed by a selector) according to a specified
 key selector function until the duration Observable expires for the key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T2,D1,D2,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#groupJoin(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2)">groupJoin</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;right,
          <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;D1&gt;&gt;&nbsp;leftDuration,
          <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super T2,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;D2&gt;&gt;&nbsp;rightDuration,
          <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;,? extends R&gt;&nbsp;resultSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that correlates two Observables when they overlap in time and groups the results.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#ignoreElements()">ignoreElements</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignores all items emitted by the source Observable and only calls <code>onCompleted</code> or <code>onError</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#interval(long, java.util.concurrent.TimeUnit)">interval</A></B>(long&nbsp;interval,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a sequential number every specified interval of time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#interval(long, java.util.concurrent.TimeUnit, rx.Scheduler)">interval</A></B>(long&nbsp;interval,
         java.util.concurrent.TimeUnit&nbsp;unit,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a sequential number every specified interval of time, on a
 specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#isEmpty()">isEmpty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits <code>true</code> if the source Observable is empty, otherwise <code>false</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TRight,TLeftDuration,TRightDuration,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#join(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2)">join</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TRight&gt;&nbsp;right,
     <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TLeftDuration&gt;&gt;&nbsp;leftDurationSelector,
     <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;TRight,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TRightDuration&gt;&gt;&nbsp;rightDurationSelector,
     <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,TRight,R&gt;&nbsp;resultSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Correlates the items emitted by two Observables based on overlapping durations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#just(T)">just</A></B>(T&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single item and then completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#just(T, rx.Scheduler)">just</A></B>(T&nbsp;value,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single item and then completes, on a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#last()">last</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
 a <code>NoSuchElementException</code> if the source Observable is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#last(rx.functions.Func1)">last</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 given condition, or notifies of a <code>NoSuchElementException</code> if no such items are emitted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#lastOrDefault(T)">lastOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last item emitted by the source Observable, or a default item
 if the source Observable completes without emitting any items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#lastOrDefault(T, rx.functions.Func1)">lastOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
              <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 specified condition, or a default item if no such item is emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#lift(rx.Observable.Operator)">lift</A></B>(<A HREF="../rx/Observable.Operator.html" title="interface in rx">Observable.Operator</A>&lt;? extends R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;lift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass
 the values of the current Observable through the Operator function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#limit(int)">limit</A></B>(int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the first <code>num</code> items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#longCount()">longCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that counts the total number of items emitted by the source Observable and emits
 this count as a 64-bit Long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#map(rx.functions.Func1)">map</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends R&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a specified function to each item emitted by the source Observable and
 emits the results of these function applications.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#materialize()">materialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that represents all of the emissions <em>and</em> notifications from the source
 Observable into emissions marked with their original types within <A HREF="../rx/Notification.html" title="class in rx"><CODE>Notification</CODE></A> objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(java.lang.Iterable)">merge</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Iterable of Observables into one Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(java.lang.Iterable, int)">merge</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
      int&nbsp;maxConcurrent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(java.lang.Iterable, int, rx.Scheduler)">merge</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
      int&nbsp;maxConcurrent,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables, and subscribing to these Observables on a
 specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(java.lang.Iterable, rx.Scheduler)">merge</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Iterable of Observables into one Observable, without any transformation, subscribing to these
 Observables on a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, int)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source,
      int&nbsp;maxConcurrent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation, while limiting the maximum number of concurrent
 subscriptions to these Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable[])">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;[]&nbsp;sequences)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Array of Observables into one Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable[], rx.Scheduler)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;[]&nbsp;sequences,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Array of Observables into one Observable, without any transformation, traversing the array on
 a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens two Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens three Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens four Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens five Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens six Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens seven Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens eight Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens nine Observables into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
 receive all successfully emitted items from all of the source Observables without being interrupted by
 an error notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens two Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from each of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens three Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens four Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens five Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens six Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens seven Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens eight Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens nine Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeMap(rx.functions.Func1)">mergeMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of applying a specified function to each item emitted by the
 source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)">mergeMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onNext,
         <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onError,
         <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onCompleted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a function to each item emitted or notification raised by the source
 Observable and then flattens the Observables returned from these functions and emits the resulting items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeMap(rx.functions.Func1, rx.functions.Func2)">mergeMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends U&gt;&gt;&nbsp;collectionSelector,
         <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super U,? extends R&gt;&nbsp;resultSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a specified function to the pair of values emitted by the
 source Observable and a specified collection Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeMapIterable(rx.functions.Func1)">mergeMapIterable</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;collectionSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that merges each item emitted by the source Observable with the values in an
 Iterable corresponding to that item that is generated by a selector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeMapIterable(rx.functions.Func1, rx.functions.Func2)">mergeMapIterable</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends java.lang.Iterable&lt;? extends U&gt;&gt;&nbsp;collectionSelector,
                 <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super U,? extends R&gt;&nbsp;resultSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of applying a function to the pair of values from the source
 Observable and an Iterable corresponding to that item that is generated by a selector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeWith(rx.Observable)">mergeWith</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens this and another Observable into a single Observable, without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TIntermediate,TResult&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TResult&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#multicast(rx.functions.Func0, rx.functions.Func1)">multicast</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TIntermediate&gt;&gt;&nbsp;subjectFactory,
          <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TIntermediate&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TResult&gt;&gt;&nbsp;selector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items produced by multicasting the source Observable within a selector
 function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#multicast(rx.subjects.Subject)">multicast</A></B>(<A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends R&gt;&nbsp;subject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that upon connection causes the source Observable to push results
 into the specified subject.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#nest()">nest</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the source <code>Observable&lt;T&gt;</code> into an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> that emits the
 source Observable as its single emission.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#never()">never</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that never sends any items or notifications to an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#observeOn(rx.Scheduler)">observeOn</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies an Observable to perform its emissions and notifications on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>,
 asynchronously with an unbounded buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#ofType(java.lang.Class)">ofType</A></B>(java.lang.Class&lt;R&gt;&nbsp;klass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters the items emitted by an Observable, only emitting those of the specified type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorFlatMap(rx.functions.Func1)">onErrorFlatMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/exceptions/OnErrorThrowable.html" title="class in rx.exceptions">OnErrorThrowable</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intercepts <code>onError</code> notifications from the source Observable and replaces them with the
 <code>onNext</code> emissions of an Observable returned by a specified function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.functions.Func1)">onErrorResumeNext</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.Observable)">onErrorResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorReturn(rx.functions.Func1)">onErrorReturn</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs an Observable to emit an item (returned by a specified function) rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onExceptionResumeNext(rx.Observable)">onExceptionResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an <CODE>Exception</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#parallel(rx.functions.Func1)">parallel</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs work on the source Observable in parallel by sharding it on a <A HREF="../rx/schedulers/Schedulers.html#computation()"><CODE>Schedulers.computation()</CODE></A>
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, and returns the resulting Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#parallel(rx.functions.Func1, rx.Scheduler)">parallel</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;f,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs work on the source Observable<T> in parallel by sharding it on a <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, and returns
 the resulting Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#parallelMerge(rx.Observable, int)">parallelMerge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source,
              int&nbsp;parallelObservables)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> into another <code>Observable&lt;Observable&lt;T&gt;&gt;</code> whose
 emitted Observables emit the same items as those emitted by the source Observable, but where the number
 of such Observables is restricted by <code>parallelObservables</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#parallelMerge(rx.Observable, int, rx.Scheduler)">parallelMerge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source,
              int&nbsp;parallelObservables,
              <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> into another <code>Observable&lt;Observable&lt;T&gt;&gt;</code> whose
 emitted Observables emit the same items as those emitted by the source Observable, but where the number
 of such Observables is restricted by <code>parallelObservables</code>, and each runs on a defined Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K1,K2,T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K2,<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K1,T&gt;&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#pivot(rx.Observable)">pivot</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K1,<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K2,T&gt;&gt;&gt;&nbsp;groups)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pivots a sequence of <code>GroupedObservable</code>s emitted by an <code>Observable</code> so as to swap the group
 and and the set on which their items are grouped.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publish()">publish</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A>, which waits until its
 <A HREF="../rx/observables/ConnectableObservable.html#connect()"><CODE>connect</CODE></A> method is called before it begins emitting items to those
 <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s that have subscribed to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publish(rx.functions.Func1)">publish</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of invoking a specified selector on items emitted by a
 <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publish(rx.functions.Func1, T)">publish</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
        <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits <code>initialValue</code> followed by the results of invoking a specified
 selector on items emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the
 source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publish(T)">publish</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that emits <code>initialValue</code> followed by the items emitted by
 the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publishLast()">publishLast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that emits only the last item emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#publishLast(rx.functions.Func1)">publishLast</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits an item that results from invoking a specified selector on the last item
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#range(int, int)">range</A></B>(int&nbsp;start,
      int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a sequence of Integers within a specified range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#range(int, int, rx.Scheduler)">range</A></B>(int&nbsp;start,
      int&nbsp;count,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a sequence of Integers within a specified range, on a specified
 Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.functions.Func2)">reduce</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 and emits the final result from the final call to your function as its sole item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(R, rx.functions.Func2)">reduce</A></B>(R&nbsp;initialValue,
       <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable and a specified seed value, then feeds the result of that function along with the second item
 emitted by an Observable into the same function, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your function as its sole item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#repeat()">repeat</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#repeat(long)">repeat</A></B>(long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#repeat(long, rx.Scheduler)">repeat</A></B>(long&nbsp;count,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times, on a particular Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#repeat(rx.Scheduler)">repeat</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely,
 on a particular Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay()">replay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying Observable
 that will replay all of its items and notifications to any future <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on the items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, int)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       int&nbsp;bufferSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying <code>bufferSize</code> notifications.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, int, long, java.util.concurrent.TimeUnit)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       int&nbsp;bufferSize,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, int, long, java.util.concurrent.TimeUnit, rx.Scheduler)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       int&nbsp;bufferSize,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, int, rx.Scheduler)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       int&nbsp;bufferSize,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying a maximum of <code>bufferSize</code> items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, long, java.util.concurrent.TimeUnit)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, long, java.util.concurrent.TimeUnit, rx.Scheduler)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.functions.Func1, rx.Scheduler)">replay</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(int)">replay</A></B>(int&nbsp;bufferSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable that
 replays at most <code>bufferSize</code> items emitted by that Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(int, long, java.util.concurrent.TimeUnit)">replay</A></B>(int&nbsp;bufferSize,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted during a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)">replay</A></B>(int&nbsp;bufferSize,
       long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 that replays a maximum of <code>bufferSize</code> items that are emitted within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(int, rx.Scheduler)">replay</A></B>(int&nbsp;bufferSize,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items emitted by that Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(long, java.util.concurrent.TimeUnit)">replay</A></B>(long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(long, java.util.concurrent.TimeUnit, rx.Scheduler)">replay</A></B>(long&nbsp;time,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#replay(rx.Scheduler)">replay</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable that
 will replay all of its items and notifications to any future <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> on the given
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#retry()">retry</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 (infinite retry count).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#retry(rx.functions.Func2)">retry</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;java.lang.Integer,java.lang.Throwable,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 and the predicate returns true for that specific exception and retry count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#retry(int)">retry</A></B>(int&nbsp;retryCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 up to a specified number of retries.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#sample(long, java.util.concurrent.TimeUnit)">sample</A></B>(long&nbsp;period,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#sample(long, java.util.concurrent.TimeUnit, rx.Scheduler)">sample</A></B>(long&nbsp;period,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals, where the intervals are defined on a particular Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#sample(rx.Observable)">sample</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;sampler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that, when the specified <code>sampler</code> Observable emits an item or completes,
 emits the most recently emitted item (if any) emitted by the source Observable since the previous
 emission from the <code>sampler</code> Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.functions.Func2)">scan</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 emitting the result of each of these iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(R, rx.functions.Func2)">scan</A></B>(R&nbsp;initialValue,
     <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable and a seed value, then feeds the result of that function along with the second item emitted by
 the source Observable into the same function, and so on until all items have been emitted by the source
 Observable, emitting the result of each of these iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#sequenceEqual(rx.Observable, rx.Observable)">sequenceEqual</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;first,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#sequenceEqual(rx.Observable, rx.Observable, rx.functions.Func2)">sequenceEqual</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;first,
              <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;second,
              <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T,? super T,java.lang.Boolean&gt;&nbsp;equality)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise based on the results of a specified
 equality function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#serialize()">serialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces an Observable's emissions and notifications to be serialized and for it to obey the Rx contract
 in other ways.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#share()">share</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> that multicasts (shares) the original <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#single()">single</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#single(rx.functions.Func1)">single</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the single item emitted by the source Observable that matches a
 specified predicate, if that Observable emits one such item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#singleOrDefault(T)">singleOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item, or a default item if the source Observable emits no items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#singleOrDefault(T, rx.functions.Func1)">singleOrDefault</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
                <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the single item emitted by the source Observable that matches a
 predicate, if that Observable emits only one such item, or a default item if the source Observable emits
 no such items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skip(int)">skip</A></B>(int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips the first <code>num</code> items emitted by the source Observable and emits
 the remainder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skip(long, java.util.concurrent.TimeUnit)">skip</A></B>(long&nbsp;time,
     java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips values emitted by the source Observable before a specified time window
 elapses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skip(long, java.util.concurrent.TimeUnit, rx.Scheduler)">skip</A></B>(long&nbsp;time,
     java.util.concurrent.TimeUnit&nbsp;unit,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips values emitted by the source Observable before a specified time window
 on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> elapses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipLast(int)">skipLast</A></B>(int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
 source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipLast(long, java.util.concurrent.TimeUnit)">skipLast</A></B>(long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that drops items emitted by the source Observable during a specified time window
 before the source completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)">skipLast</A></B>(long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that drops items emitted by the source Observable during a specified time window
 (defined on a specified scheduler) before the source completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipUntil(rx.Observable)">skipUntil</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips items emitted by the source Observable until a second Observable emits
 an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipWhile(rx.functions.Func1)">skipWhile</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips all items emitted by the source Observable as long as a specified
 condition holds true, but emits all further source items as soon as the condition becomes false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skipWhileWithIndex(rx.functions.Func2)">skipWhileWithIndex</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that skips all items emitted by the source Observable as long as a specified
 condition holds true, but emits all further source items as soon as the condition becomes false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(java.lang.Iterable)">startWith</A></B>(java.lang.Iterable&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items in a specified <CODE>Iterable</CODE> before it begins to emit items
 emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(java.lang.Iterable, rx.Scheduler)">startWith</A></B>(java.lang.Iterable&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values,
          <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items in a specified <CODE>Iterable</CODE>, on a specified
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, before it begins to emit items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(rx.Observable)">startWith</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items in a specified <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> before it begins to emit
 items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a specified item before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T[], rx.Scheduler)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>[]&nbsp;values,
          <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items from a specified array, on a specified Scheduler, before it
 begins to emit items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T, T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#startWith(T, T, T, T, T, T, T, T, T)">startWith</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t8,
          <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t9)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe()">subscribe</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable but ignore its emissions and notifications.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.functions.Action1)">subscribe</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and provides a callback to handle the items it emits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1)">subscribe</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
          <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and provides callbacks to handle the items it emits and any error
 notification it issues.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0)">subscribe</A></B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
          <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError,
          <A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onComplete)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and provides callbacks to handle the items it emits and any error or
 completion notification it issues.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.Observer)">subscribe</A></B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and provides an Observer that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.Subscriber)">subscribe</A></B>(<A HREF="../rx/Subscriber.html" title="class in rx">Subscriber</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;subscriber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and provides a Subscriber that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribeOn(rx.Scheduler)">subscribeOn</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously subscribes Observers to this Observable on the specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#switchMap(rx.functions.Func1)">switchMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new Observable by applying a function that you supply to each item emitted by the source
 Observable that returns an Observable, and then emitting the items emitted by the most recently emitted
 of these Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#switchOnNext(rx.Observable)">switchOnNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequenceOfSequences)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Observable that emits Observables into an Observable that emits the items emitted by the
 most recently emitted of those Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#take(int)">take</A></B>(int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the first <code>num</code> items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#take(long, java.util.concurrent.TimeUnit)">take</A></B>(long&nbsp;time,
     java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits those items emitted by source Observable before a specified time runs
 out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#take(long, java.util.concurrent.TimeUnit, rx.Scheduler)">take</A></B>(long&nbsp;time,
     java.util.concurrent.TimeUnit&nbsp;unit,
     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits those items emitted by source Observable before a specified time (on a
 specified Scheduler) runs out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeFirst(rx.functions.Func1)">takeFirst</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLast(int)">takeLast</A></B>(int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last <code>count</code> items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLast(int, long, java.util.concurrent.TimeUnit)">takeLast</A></B>(int&nbsp;count,
         long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLast(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)">takeLast</A></B>(int&nbsp;count,
         long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed, where the timing information is
 provided by a given Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLast(long, java.util.concurrent.TimeUnit)">takeLast</A></B>(long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)">takeLast</A></B>(long&nbsp;time,
         java.util.concurrent.TimeUnit&nbsp;unit,
         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed, where the timing information is provided by a specified
 Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLastBuffer(int)">takeLastBuffer</A></B>(int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single List containing the last <code>count</code> elements emitted by the
 source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLastBuffer(int, long, java.util.concurrent.TimeUnit)">takeLastBuffer</A></B>(int&nbsp;count,
               long&nbsp;time,
               java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time before the source Observable completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLastBuffer(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)">takeLastBuffer</A></B>(int&nbsp;count,
               long&nbsp;time,
               java.util.concurrent.TimeUnit&nbsp;unit,
               <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time (on a specified Scheduler) before the
 source Observable completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLastBuffer(long, java.util.concurrent.TimeUnit)">takeLastBuffer</A></B>(long&nbsp;time,
               java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeLastBuffer(long, java.util.concurrent.TimeUnit, rx.Scheduler)">takeLastBuffer</A></B>(long&nbsp;time,
               java.util.concurrent.TimeUnit&nbsp;unit,
               <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed, where the timing
 information is provided by the given Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeUntil(rx.Observable)">takeUntil</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends E&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by the source Observable until a second Observable
 emits an item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeWhile(rx.functions.Func1)">takeWhile</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items emitted by the source Observable so long as each item satisfied a
 specified condition, and then completes as soon as this condition is not satisfied.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#takeWhileWithIndex(rx.functions.Func2)">takeWhileWithIndex</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super java.lang.Integer,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the items emitted by a source Observable so long as a given predicate
 remains true, where the predicate operates on both the item and its index relative to the complete
 sequence of emitted items.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit)">throttleFirst</A></B>(long&nbsp;windowDuration,
              java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit, rx.Scheduler)">throttleFirst</A></B>(long&nbsp;skipDuration,
              java.util.concurrent.TimeUnit&nbsp;unit,
              <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration, where the windows are managed by a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit)">throttleLast</A></B>(long&nbsp;intervalDuration,
             java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)">throttleLast</A></B>(long&nbsp;intervalDuration,
             java.util.concurrent.TimeUnit&nbsp;unit,
             <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration, where the duration is governed by a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit)">throttleWithTimeout</A></B>(long&nbsp;timeout,
                    java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit, rx.Scheduler)">throttleWithTimeout</A></B>(long&nbsp;timeout,
                    java.util.concurrent.TimeUnit&nbsp;unit,
                    <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window, where the time window is governed by a specified
 Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/TimeInterval.html" title="class in rx.schedulers">TimeInterval</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeInterval()">timeInterval</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/TimeInterval.html" title="class in rx.schedulers">TimeInterval</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeInterval(rx.Scheduler)">timeInterval</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable, where this interval is computed on a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(rx.functions.Func0, rx.functions.Func1)">timeout</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;firstTimeoutSelector,
        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
 either the first item emitted by the source Observable or any subsequent item don't arrive within time
 windows defined by other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(rx.functions.Func0, rx.functions.Func1, rx.Observable)">timeout</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;firstTimeoutSelector,
        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector,
        <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, but switches to a fallback Observable if either
 the first item emitted by the source Observable or any subsequent item don't arrive within time windows
 defined by other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(rx.functions.Func1)">timeout</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
 an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
 previous item, where that period of time is measured by an Observable that is a function of the previous
 item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(rx.functions.Func1, rx.Observable)">timeout</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector,
        <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable, but that switches to a fallback Observable if
 an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
 previous item, where that period of time is measured by an Observable that is a function of the previous
 item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit)">timeout</A></B>(long&nbsp;timeout,
        java.util.concurrent.TimeUnit&nbsp;timeUnit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Observable)">timeout</A></B>(long&nbsp;timeout,
        java.util.concurrent.TimeUnit&nbsp;timeUnit,
        <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Observable, rx.Scheduler)">timeout</A></B>(long&nbsp;timeout,
        java.util.concurrent.TimeUnit&nbsp;timeUnit,
        <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other,
        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item using a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Scheduler)">timeout</A></B>(long&nbsp;timeout,
        java.util.concurrent.TimeUnit&nbsp;timeUnit,
        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item, where this policy is governed on a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timer(long, long, java.util.concurrent.TimeUnit)">timer</A></B>(long&nbsp;initialDelay,
      long&nbsp;period,
      java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)">timer</A></B>(long&nbsp;initialDelay,
      long&nbsp;period,
      java.util.concurrent.TimeUnit&nbsp;unit,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter, on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timer(long, java.util.concurrent.TimeUnit)">timer</A></B>(long&nbsp;delay,
      java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits one item after a specified delay, and then completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timer(long, java.util.concurrent.TimeUnit, rx.Scheduler)">timer</A></B>(long&nbsp;delay,
      java.util.concurrent.TimeUnit&nbsp;unit,
      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits one item after a specified delay, on a specified Scheduler, and then
 completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers">Timestamped</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timestamp()">timestamp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers"><CODE>Timestamped</CODE></A> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers">Timestamped</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#timestamp(rx.Scheduler)">timestamp</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers"><CODE>Timestamped</CODE></A> object whose timestamps are provided by a specified Scheduler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables">BlockingObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toBlocking()">toBlocking</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Observable into a <A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables"><CODE>BlockingObservable</CODE></A> (an Observable with blocking operators).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables">BlockingObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toBlockingObservable()">toBlockingObservable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use <A HREF="../rx/Observable.html#toBlocking()"><CODE>Observable.toBlocking()</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toList()">toList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single item, a list composed of all the items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMap(rx.functions.Func1)">toMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single HashMap containing all items emitted by the source Observable,
 mapped by the keys returned by a specified <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMap(rx.functions.Func1, rx.functions.Func1)">toMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
      <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single HashMap containing values corresponding to items emitted by the
 source Observable, mapped by the keys returned by a specified <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)">toMap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
      <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
      <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,V&gt;&gt;&nbsp;mapFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains keys and values extracted from the items emitted by the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMultimap(rx.functions.Func1)">toMultimap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single HashMap that contains an ArrayList of items emitted by the
 source Observable keyed by a specified <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1)">toMultimap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
           <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single HashMap that contains an ArrayList of values extracted by a
 specified <code>valueSelector</code> function from items emitted by the source Observable, keyed by a
 specified <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)">toMultimap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
           <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
           <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains an ArrayList of values, extracted by a specified <code>valueSelector</code> function from items
 emitted by the source Observable and keyed by the <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0, rx.functions.Func1)">toMultimap</A></B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
           <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
           <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapFactory,
           <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super K,? extends java.util.Collection&lt;V&gt;&gt;&nbsp;collectionFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains a custom collection of values, extracted by a specified <code>valueSelector</code> function from
 items emitted by the source Observable, and keyed by the <code>keySelector</code> function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList()">toSortedList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(rx.functions.Func2)">toSortedList</A></B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer&gt;&nbsp;sortFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order based on a specified comparison function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#unsafeSubscribe(rx.Subscriber)">unsafeSubscribe</A></B>(<A HREF="../rx/Subscriber.html" title="class in rx">Subscriber</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;subscriber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subscribes to an Observable and invokes <A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><CODE>Observable.OnSubscribe</CODE></A> function without any contract protection,
 error handling, unsubscribe, or execution hooks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#unsubscribeOn(rx.Scheduler)">unsubscribeOn</A></B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifies the source Observable so that subscribers will unsubscribe from it on a specified
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,Resource extends <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#using(rx.functions.Func0, rx.functions.Func1)">using</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;Resource&gt;&nbsp;resourceFactory,
      <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;Resource,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observableFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an Observable that creates a dependent resource object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(rx.functions.Func0)">window</A></B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;closingSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(int)">window</A></B>(int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(int, int)">window</A></B>(int&nbsp;count,
       int&nbsp;skip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit)">window</A></B>(long&nbsp;timespan,
       long&nbsp;timeshift,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)">window</A></B>(long&nbsp;timespan,
       long&nbsp;timeshift,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, java.util.concurrent.TimeUnit)">window</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int)">window</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)">window</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       int&nbsp;count,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(long, java.util.concurrent.TimeUnit, rx.Scheduler)">window</A></B>(long&nbsp;timespan,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;TOpening,TClosing&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(rx.Observable, rx.functions.Func1)">window</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TOpening&gt;&nbsp;windowOpenings,
       <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super TOpening,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;closingSelector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits windows of items it collects from the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#window(rx.Observable)">window</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;boundary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits non-overlapping windows of items it collects from the source Observable
 where the boundary of each window is determined by the items emitted from a specified boundary-governing
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(java.lang.Iterable, rx.functions.FuncN)">zip</A></B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;?&gt;&gt;&nbsp;ws,
    <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 items emitted, in sequence, by an Iterable of other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(java.lang.Iterable, rx.functions.Func2)">zip</A></B>(java.lang.Iterable&lt;? extends T2&gt;&nbsp;other,
    <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super T2,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and a specified Iterable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.functions.FuncN)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;?&gt;&gt;&nbsp;ws,
    <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 <i>n</i> items emitted, in sequence, by the <i>n</i> Observables emitted by a specified Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.functions.Func2)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T1,? super T2,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 two items emitted, in sequence, by two other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.functions.Func3)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/functions/Func3.html" title="interface in rx.functions">Func3</A>&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 three items emitted, in sequence, by three other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func4)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/functions/Func4.html" title="interface in rx.functions">Func4</A>&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 four items emitted, in sequence, by four other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func5)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
    <A HREF="../rx/functions/Func5.html" title="interface in rx.functions">Func5</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 five items emitted, in sequence, by five other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func6)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
    <A HREF="../rx/functions/Func6.html" title="interface in rx.functions">Func6</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 six items emitted, in sequence, by six other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func7)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
    <A HREF="../rx/functions/Func7.html" title="interface in rx.functions">Func7</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 seven items emitted, in sequence, by seven other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,T8,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func8)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
    <A HREF="../rx/functions/Func8.html" title="interface in rx.functions">Func8</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 eight items emitted, in sequence, by eight other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,R&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func9)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T9&gt;&nbsp;o9,
    <A HREF="../rx/functions/Func9.html" title="interface in rx.functions">Func9</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits the results of a function of your choosing applied to combinations of
 nine items emitted, in sequence, by nine other Observables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.functions.Func2)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;other,
    <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super T2,? extends R&gt;&nbsp;zipFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and another specified Observable.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Observable(rx.Observable.OnSubscribe)"><!-- --></A><H3>
Observable</H3>
<PRE>
protected <B>Observable</B>(<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx">Observable.OnSubscribe</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;f)</PRE>
<DL>
<DD>Creates an Observable with a Function to execute when it is subscribed to.
 <p>
 <em>Note:</em> Use <A HREF="../rx/Observable.html#create(rx.Observable.OnSubscribe)"><CODE>Observable.create(OnSubscribe)</CODE></A> to create an Observable, instead of this constructor,
 unless you specifically have a need for inheritance.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - <A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><CODE>Observable.OnSubscribe</CODE></A> to be executed when <A HREF="../rx/Observable.html#subscribe(rx.Subscriber)"><CODE>Observable.subscribe(Subscriber)</CODE></A> is called</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="create(rx.Observable.OnSubscribe)"><!-- --></A><H3>
create</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>create</B>(<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx">Observable.OnSubscribe</A>&lt;T&gt;&nbsp;f)</PRE>
<DL>
<DD>Returns an Observable that will execute the specified function when a <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> subscribes to
 it.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/create.png">
 <p>
 Write the function you pass to <code>create</code> so that it behaves as an Observable: It should invoke the
 Subscriber's <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>, <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>, and
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> methods appropriately.
 <p>
 A well-formed Observable must invoke either the Subscriber's <code>onCompleted</code> method exactly once or
 its <code>onError</code> method exactly once.
 <p>
 See <a href="http://go.microsoft.com/fwlink/?LinkID=205219">Rx Design Guidelines (PDF)</a> for detailed
 information.
 <p>
 <code>create</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items that this Observable emits<DT><B>Parameters:</B><DD><CODE>f</CODE> - a function that accepts an <code>Subscriber&lt;T&gt;</code>, and invokes its <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods as appropriate
<DT><B>Returns:</B><DD>an Observable that, when a <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> subscribes to it, will execute the specified
         function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#create">RxJava Wiki: create()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.create.aspx">MSDN: Observable.Create</a></DL>
</DD>
</DL>
<HR>

<A NAME="create(rx.Observable.OnSubscribeFunc)"><!-- --></A><H3>
create</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>create</B>(<A HREF="../rx/Observable.OnSubscribeFunc.html" title="interface in rx">Observable.OnSubscribeFunc</A>&lt;T&gt;&nbsp;f)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../rx/Observable.html#create(rx.Observable.OnSubscribe)"><CODE>Observable.create(OnSubscribe)</CODE></A></I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lift(rx.Observable.Operator)"><!-- --></A><H3>
lift</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>lift</B>(<A HREF="../rx/Observable.Operator.html" title="interface in rx">Observable.Operator</A>&lt;? extends R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;lift)</PRE>
<DL>
<DD>Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass
 the values of the current Observable through the Operator function.
 <p>
 In other words, this allows chaining Observers together on an Observable for acting on the values within
 the Observable.
 <p> <code>observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()
 </code>
 <p>
 <code>lift</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lift</CODE> - the Operator that implements the Observable-operating function to be applied to the source
             Observable
<DT><B>Returns:</B><DD>an Observable that is the result of applying the lifted Operator to the source Observable<DT><B>Since:</B></DT>
  <DD>0.17</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="amb(java.lang.Iterable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sources)</PRE>
<DL>
<DD>Mirrors the one Observable in an Iterable of several Observables that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sources</CODE> - an Iterable of Observable sources competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229115.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2)</PRE>
<DL>
<DD>Given two Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3)</PRE>
<DL>
<DD>Given three Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4)</PRE>
<DL>
<DD>Given four Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5)</PRE>
<DL>
<DD>Given five Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first<DD><CODE>o5</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6)</PRE>
<DL>
<DD>Given six Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first<DD><CODE>o5</CODE> - an Observable competing to react first<DD><CODE>o6</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7)</PRE>
<DL>
<DD>Given seven Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first<DD><CODE>o5</CODE> - an Observable competing to react first<DD><CODE>o6</CODE> - an Observable competing to react first<DD><CODE>o7</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o8)</PRE>
<DL>
<DD>Given eight Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first<DD><CODE>o5</CODE> - an Observable competing to react first<DD><CODE>o6</CODE> - an Observable competing to react first<DD><CODE>o7</CODE> - an Observable competing to react first<DD><CODE>o8</CODE> - an observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="amb(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
amb</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>amb</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o1,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o2,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o3,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o4,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o5,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o6,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o7,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o8,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;o9)</PRE>
<DL>
<DD>Given nine Observables, mirrors the one that first emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - an Observable competing to react first<DD><CODE>o2</CODE> - an Observable competing to react first<DD><CODE>o3</CODE> - an Observable competing to react first<DD><CODE>o4</CODE> - an Observable competing to react first<DD><CODE>o5</CODE> - an Observable competing to react first<DD><CODE>o6</CODE> - an Observable competing to react first<DD><CODE>o7</CODE> - an Observable competing to react first<DD><CODE>o8</CODE> - an Observable competing to react first<DD><CODE>o9</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.functions.Func2)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                          <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T1,? super T2,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines two source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from either of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.functions.Func3)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                             <A HREF="../rx/functions/Func3.html" title="interface in rx.functions">Func3</A>&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines three source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func4)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                <A HREF="../rx/functions/Func4.html" title="interface in rx.functions">Func4</A>&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines four source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func5)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                   <A HREF="../rx/functions/Func5.html" title="interface in rx.functions">Func5</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines five source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>o5</CODE> - the fifth source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func6)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                      <A HREF="../rx/functions/Func6.html" title="interface in rx.functions">Func6</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines six source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>o5</CODE> - the fifth source Observable<DD><CODE>o6</CODE> - the sixth source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func7)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                                         <A HREF="../rx/functions/Func7.html" title="interface in rx.functions">Func7</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines seven source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>o5</CODE> - the fifth source Observable<DD><CODE>o6</CODE> - the sixth source Observable<DD><CODE>o7</CODE> - the seventh source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func8)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,T8,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
                                                                            <A HREF="../rx/functions/Func8.html" title="interface in rx.functions">Func8</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines eight source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>o5</CODE> - the fifth source Observable<DD><CODE>o6</CODE> - the sixth source Observable<DD><CODE>o7</CODE> - the seventh source Observable<DD><CODE>o8</CODE> - the eighth source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func9)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
                                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T9&gt;&nbsp;o9,
                                                                               <A HREF="../rx/functions/Func9.html" title="interface in rx.functions">Func9</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines nine source Observables by emitting an item that aggregates the latest values of each of the
 source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/combineLatest.png">
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - the second source Observable<DD><CODE>o3</CODE> - the third source Observable<DD><CODE>o4</CODE> - the fourth source Observable<DD><CODE>o5</CODE> - the fifth source Observable<DD><CODE>o6</CODE> - the sixth source Observable<DD><CODE>o7</CODE> - the seventh source Observable<DD><CODE>o8</CODE> - the eighth source Observable<DD><CODE>o9</CODE> - the ninth source Observable<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="combineLatest(java.util.List, rx.functions.FuncN)"><!-- --></A><H3>
combineLatest</H3>
<PRE>
public static final &lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>combineLatest</B>(java.util.List&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sources,
                                                      <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;combineFunction)</PRE>
<DL>
<DD>Combines a list of source Observables by emitting an item that aggregates the latest values of each of
 the source Observables each time an item is received from any of the source Observables, where this
 aggregation is defined by a specified function.
 <p>
 <code>combineLatest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the common base type of source values<DD><CODE>R</CODE> - the result type<DT><B>Parameters:</B><DD><CODE>sources</CODE> - the list of source Observables<DD><CODE>combineFunction</CODE> - the aggregation function used to combine the items emitted by the source Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of combining the items emitted by the source
         Observables by means of the given aggregation function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#combinelatest">RxJava Wiki: combineLatest()</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observables)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by each of the Observables emitted by the source
 Observable, one after the other, without interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>observables</CODE> - an Observable that emits Observables
<DT><B>Returns:</B><DD>an Observable that emits items all of the items emitted by the Observables emitted by
         <code>observables</code>, one after the other, without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by two Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the two source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by three Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the three source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by four Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the four source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by five Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated<DD><CODE>t5</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the five source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by six Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated<DD><CODE>t5</CODE> - an Observable to be concatenated<DD><CODE>t6</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the six source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by seven Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated<DD><CODE>t5</CODE> - an Observable to be concatenated<DD><CODE>t6</CODE> - an Observable to be concatenated<DD><CODE>t7</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the seven source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by eight Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated<DD><CODE>t5</CODE> - an Observable to be concatenated<DD><CODE>t6</CODE> - an Observable to be concatenated<DD><CODE>t7</CODE> - an Observable to be concatenated<DD><CODE>t8</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the eight source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by nine Observables, one after the other, without
 interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated<DD><CODE>t2</CODE> - an Observable to be concatenated<DD><CODE>t3</CODE> - an Observable to be concatenated<DD><CODE>t4</CODE> - an Observable to be concatenated<DD><CODE>t5</CODE> - an Observable to be concatenated<DD><CODE>t6</CODE> - an Observable to be concatenated<DD><CODE>t7</CODE> - an Observable to be concatenated<DD><CODE>t8</CODE> - an Observable to be concatenated<DD><CODE>t9</CODE> - an Observable to be concatenated
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the nine source Observables, one after the other,
         without interleaving them<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="defer(rx.functions.Func0)"><!-- --></A><H3>
defer</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>defer</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observableFactory)</PRE>
<DL>
<DD>Returns an Observable that calls an Observable factory to create an Observable for each new Observer
 that subscribes. That is, for each subscriber, the actual Observable that subscriber observes is
 determined by the factory function.
 <p>
 <img width="640" height="340" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/defer.png">
 <p>
 The defer Observer allows you to defer or delay emitting items from an Observable until such time as an
 Observer subscribes to the Observable. This allows an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> to easily obtain updates or a
 refreshed version of the sequence.
 <p>
 <code>defer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items emitted by the Observable<DT><B>Parameters:</B><DD><CODE>observableFactory</CODE> - the Observable factory function to invoke for each <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> that subscribes to the
            resulting Observable
<DT><B>Returns:</B><DD>an Observable whose <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s' subscriptions trigger an invocation of the given
         Observable factory function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#defer">RxJava Wiki: defer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="empty()"><!-- --></A><H3>
empty</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>empty</B>()</PRE>
<DL>
<DD>Returns an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> and immediately invokes its
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/empty.png">
 <p>
 <code>empty</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items (ostensibly) emitted by the Observable
<DT><B>Returns:</B><DD>an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> but immediately invokes the
         <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#empty-error-and-never">RxJava Wiki: empty()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229670.aspx">MSDN: Observable.Empty</a></DL>
</DD>
</DL>
<HR>

<A NAME="empty(rx.Scheduler)"><!-- --></A><H3>
empty</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>empty</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> and immediately invokes its
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method on the specified Scheduler.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/empty.s.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items (ostensibly) emitted by the Observable<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the Scheduler to use to call the <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method
<DT><B>Returns:</B><DD>an Observable that emits no items to the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> but immediately invokes the
         <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method with the specified
         <code>scheduler</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#empty-error-and-never">RxJava Wiki: empty()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229066.aspx">MSDN: Observable.Empty Method (IScheduler)</a></DL>
</DD>
</DL>
<HR>

<A NAME="error(java.lang.Throwable)"><!-- --></A><H3>
error</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>error</B>(java.lang.Throwable&nbsp;exception)</PRE>
<DL>
<DD>Returns an Observable that invokes an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method when the
 Observer subscribes to it.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/error.png">
 <p>
 <code>error</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items (ostensibly) emitted by the Observable<DT><B>Parameters:</B><DD><CODE>exception</CODE> - the particular Throwable to pass to <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>
<DT><B>Returns:</B><DD>an Observable that invokes the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method when
         the Observer subscribes to it<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#empty-error-and-never">RxJava Wiki: error()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244299.aspx">MSDN: Observable.Throw</a></DL>
</DD>
</DL>
<HR>

<A NAME="error(java.lang.Throwable, rx.Scheduler)"><!-- --></A><H3>
error</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>error</B>(java.lang.Throwable&nbsp;exception,
                                            <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that invokes an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method on the
 specified Scheduler.
 <p>
 <img width="640" height="190" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/error.s.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the items (ostensibly) emitted by the Observable<DT><B>Parameters:</B><DD><CODE>exception</CODE> - the particular Throwable to pass to <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A><DD><CODE>scheduler</CODE> - the Scheduler on which to call <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>
<DT><B>Returns:</B><DD>an Observable that invokes the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> method, on
         the specified Scheduler<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#empty-error-and-never">RxJava Wiki: error()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211711.aspx">MSDN: Observable.Throw</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.util.concurrent.Future)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future)</PRE>
<DL>
<DD>Converts a <CODE>Future</CODE> into an Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.Future.png">
 <p>
 You can convert any object that supports the <CODE>Future</CODE> interface into an Observable that emits the
 return value of the <CODE>Future.get()</CODE> method of that object, by passing the object into the <code>from</code>
 method.
 <p>
 <em>Important note:</em> This Observable is blocking; you cannot unsubscribe from it.
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of object that the <CODE>Future</CODE> returns, and also the type of item to be emitted by
            the resulting Observable<DT><B>Parameters:</B><DD><CODE>future</CODE> - the source <CODE>Future</CODE>
<DT><B>Returns:</B><DD>an Observable that emits the item from the source <CODE>Future</CODE><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future,
                                           long&nbsp;timeout,
                                           java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Converts a <CODE>Future</CODE> into an Observable, with a timeout on the Future.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.Future.png">
 <p>
 You can convert any object that supports the <CODE>Future</CODE> interface into an Observable that emits the
 return value of the <CODE>Future.get()</CODE> method of that object, by passing the object into the <code>from</code>
 method.
 <p>
 <em>Important note:</em> This Observable is blocking; you cannot unsubscribe from it.
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of object that the <CODE>Future</CODE> returns, and also the type of item to be emitted by
            the resulting Observable<DT><B>Parameters:</B><DD><CODE>future</CODE> - the source <CODE>Future</CODE><DD><CODE>timeout</CODE> - the maximum time to wait before calling <code>get</code><DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> of the <code>timeout</code> argument
<DT><B>Returns:</B><DD>an Observable that emits the item from the source <CODE>Future</CODE><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.util.concurrent.Future, rx.Scheduler)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.util.concurrent.Future&lt;? extends T&gt;&nbsp;future,
                                           <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Converts a <CODE>Future</CODE>, operating on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, into an Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.Future.s.png">
 <p>
 You can convert any object that supports the <CODE>Future</CODE> interface into an Observable that emits the
 return value of the <CODE>Future.get()</CODE> method of that object, by passing the object into the <code>from</code>
 method.
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of object that the <CODE>Future</CODE> returns, and also the type of item to be emitted by
            the resulting Observable<DT><B>Parameters:</B><DD><CODE>future</CODE> - the source <CODE>Future</CODE><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to wait for the Future on. Use a Scheduler such as
            <A HREF="../rx/schedulers/Schedulers.html#io()"><CODE>Schedulers.io()</CODE></A> that can block and wait on the Future
<DT><B>Returns:</B><DD>an Observable that emits the item from the source <CODE>Future</CODE><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Iterable)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable)</PRE>
<DL>
<DD>Converts an <CODE>Iterable</CODE> sequence into an Observable that emits the items in the sequence.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the <CODE>Iterable</CODE> sequence and the type of items to be emitted by the
            resulting Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source <CODE>Iterable</CODE> sequence
<DT><B>Returns:</B><DD>an Observable that emits each item in the source <CODE>Iterable</CODE> sequence<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Iterable, rx.Scheduler)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.lang.Iterable&lt;? extends T&gt;&nbsp;iterable,
                                           <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Converts an <CODE>Iterable</CODE> sequence into an Observable that operates on the specified Scheduler,
 emitting each item from the sequence.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.s.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the <CODE>Iterable</CODE> sequence and the type of items to be emitted by the
            resulting Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source <CODE>Iterable</CODE> sequence<DD><CODE>scheduler</CODE> - the Scheduler on which the Observable is to emit the items of the Iterable
<DT><B>Returns:</B><DD>an Observable that emits each item in the source <CODE>Iterable</CODE> sequence, on the specified
         Scheduler<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212140.aspx">MSDN: Observable.ToObservable</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object)"><!-- --></A><A NAME="from(T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1)</PRE>
<DL>
<DD>Converts an item into an Observable that emits that item.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the item<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the item
<DT><B>Returns:</B><DD>an Observable that emits the item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2)</PRE>
<DL>
<DD>Converts two items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3)</PRE>
<DL>
<DD>Converts three items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4)</PRE>
<DL>
<DD>Converts four items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5)</PRE>
<DL>
<DD>Converts five items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5,
                                           T&nbsp;t6)</PRE>
<DL>
<DD>Converts six items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item<DD><CODE>t6</CODE> - sixth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5,
                                           T&nbsp;t6,
                                           T&nbsp;t7)</PRE>
<DL>
<DD>Converts seven items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item<DD><CODE>t6</CODE> - sixth item<DD><CODE>t7</CODE> - seventh item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5,
                                           T&nbsp;t6,
                                           T&nbsp;t7,
                                           T&nbsp;t8)</PRE>
<DL>
<DD>Converts eight items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item<DD><CODE>t6</CODE> - sixth item<DD><CODE>t7</CODE> - seventh item<DD><CODE>t8</CODE> - eighth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5,
                                           T&nbsp;t6,
                                           T&nbsp;t7,
                                           T&nbsp;t8,
                                           T&nbsp;t9)</PRE>
<DL>
<DD>Converts nine items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item<DD><CODE>t6</CODE> - sixth item<DD><CODE>t7</CODE> - seventh item<DD><CODE>t8</CODE> - eighth item<DD><CODE>t9</CODE> - ninth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="from(T, T, T, T, T, T, T, T, T, T)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T&nbsp;t1,
                                           T&nbsp;t2,
                                           T&nbsp;t3,
                                           T&nbsp;t4,
                                           T&nbsp;t5,
                                           T&nbsp;t6,
                                           T&nbsp;t7,
                                           T&nbsp;t8,
                                           T&nbsp;t9,
                                           T&nbsp;t10)</PRE>
<DL>
<DD>Converts ten items into an Observable that emits those items.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of these items<DT><B>Parameters:</B><DD><CODE>t1</CODE> - first item<DD><CODE>t2</CODE> - second item<DD><CODE>t3</CODE> - third item<DD><CODE>t4</CODE> - fourth item<DD><CODE>t5</CODE> - fifth item<DD><CODE>t6</CODE> - sixth item<DD><CODE>t7</CODE> - seventh item<DD><CODE>t8</CODE> - eighth item<DD><CODE>t9</CODE> - ninth item<DD><CODE>t10</CODE> - tenth item
<DT><B>Returns:</B><DD>an Observable that emits each item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object[])"><!-- --></A><A NAME="from(T...)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T...&nbsp;t1)</PRE>
<DL>
<DD>Converts an Array into an Observable that emits the items in the Array.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
 <p>
 <code>from</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the Array and the type of items to be emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the source Array
<DT><B>Returns:</B><DD>an Observable that emits each item in the source Array<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object[],rx.Scheduler)"><!-- --></A><A NAME="from(T[], rx.Scheduler)"><!-- --></A><H3>
from</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T[]&nbsp;items,
                                           <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Converts an Array into an Observable that emits the items in the Array on a specified Scheduler.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/from.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the Array and the type of items to be emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>items</CODE> - the source Array<DD><CODE>scheduler</CODE> - the Scheduler on which the Observable emits the items of the Array
<DT><B>Returns:</B><DD>an Observable that emits each item in the source Array<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#from">RxJava Wiki: from()</a></DL>
</DD>
</DL>
<HR>

<A NAME="interval(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
interval</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>interval</B>(long&nbsp;interval,
                                                        java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits a sequential number every specified interval of time.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/interval.png">
 <p>
 <code>interval</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>interval</CODE> - interval size in time units (see below)<DD><CODE>unit</CODE> - time units to use for the interval size
<DT><B>Returns:</B><DD>an Observable that emits a sequential number each time interval<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#interval">RxJava Wiki: interval()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229027.aspx">MSDN: Observable.Interval</a></DL>
</DD>
</DL>
<HR>

<A NAME="interval(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
interval</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>interval</B>(long&nbsp;interval,
                                                        java.util.concurrent.TimeUnit&nbsp;unit,
                                                        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a sequential number every specified interval of time, on a
 specified Scheduler.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/interval.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>interval</CODE> - interval size in time units (see below)<DD><CODE>unit</CODE> - time units to use for the interval size<DD><CODE>scheduler</CODE> - the Scheduler to use for scheduling the items
<DT><B>Returns:</B><DD>an Observable that emits a sequential number each time interval<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#interval">RxJava Wiki: interval()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh228911.aspx">MSDN: Observable.Interval</a></DL>
</DD>
</DL>
<HR>

<A NAME="just(java.lang.Object)"><!-- --></A><A NAME="just(T)"><!-- --></A><H3>
just</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>just</B>(T&nbsp;value)</PRE>
<DL>
<DD>Returns an Observable that emits a single item and then completes.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/just.png">
 <p>
 To convert any object into an Observable that emits that object, pass that object into the <code>just</code>
 method.
 <p>
 This is similar to the <A HREF="../rx/Observable.html#from(T...)"><CODE>Observable.from(java.lang.Object[])</CODE></A> method, except that <code>from</code> will convert
 an <CODE>Iterable</CODE> object into an Observable that emits each of the items in the Iterable, one at a
 time, while the <code>just</code> method converts an Iterable into an Observable that emits the entire
 Iterable as a single item.
 <p>
 <code>just</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of that item<DT><B>Parameters:</B><DD><CODE>value</CODE> - the item to emit
<DT><B>Returns:</B><DD>an Observable that emits <code>value</code> as a single item and then completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#just">RxJava Wiki: just()</a></DL>
</DD>
</DL>
<HR>

<A NAME="just(java.lang.Object,rx.Scheduler)"><!-- --></A><A NAME="just(T, rx.Scheduler)"><!-- --></A><H3>
just</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>just</B>(T&nbsp;value,
                                           <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a single item and then completes, on a specified Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/just.s.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of that item<DT><B>Parameters:</B><DD><CODE>value</CODE> - the item to emit<DD><CODE>scheduler</CODE> - the Scheduler to emit the single item on
<DT><B>Returns:</B><DD>an Observable that emits <code>value</code> as a single item and then completes, on a specified
         Scheduler<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#just">RxJava Wiki: just()</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.lang.Iterable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences)</PRE>
<DL>
<DD>Flattens an Iterable of Observables into one Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Iterable of Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the items emitted by the
         Observables in the Iterable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229590.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.lang.Iterable, int)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
                                            int&nbsp;maxConcurrent)</PRE>
<DL>
<DD>Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Iterable of Observables<DD><CODE>maxConcurrent</CODE> - the maximum number of Observables that may be subscribed to concurrently
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the items emitted by the
         Observables in the Iterable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>maxConcurrent</code> is less than or equal to 0<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229923.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.lang.Iterable, int, rx.Scheduler)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
                                            int&nbsp;maxConcurrent,
                                            <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
 number of concurrent subscriptions to these Observables, and subscribing to these Observables on a
 specified Scheduler.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Iterable of Observables<DD><CODE>maxConcurrent</CODE> - the maximum number of Observables that may be subscribed to concurrently<DD><CODE>scheduler</CODE> - the Scheduler on which to traverse the Iterable of Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the items emitted by the
         Observables in the Iterable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>maxConcurrent</code> is less than or equal to 0<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244329.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.lang.Iterable, rx.Scheduler)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequences,
                                            <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Flattens an Iterable of Observables into one Observable, without any transformation, subscribing to these
 Observables on a specified Scheduler.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Iterable of Observables<DD><CODE>scheduler</CODE> - the Scheduler on which to traverse the Iterable of Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the items emitted by the
         Observables in the Iterable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244336.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.oo.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - an Observable that emits Observables
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the Observables emitted by the
         <code>source</code> Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, int)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source,
                                            int&nbsp;maxConcurrent)</PRE>
<DL>
<DD>Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
 those Observables, without any transformation, while limiting the maximum number of concurrent
 subscriptions to these Observables.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.oo.png">
 <p>
 You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - an Observable that emits Observables<DD><CODE>maxConcurrent</CODE> - the maximum number of Observables that may be subscribed to concurrently
<DT><B>Returns:</B><DD>an Observable that emits items that are the result of flattening the Observables emitted by the
         <code>source</code> Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>maxConcurrent</code> is less than or equal to 0<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211914.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</PRE>
<DL>
<DD>Flattens two Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</PRE>
<DL>
<DD>Flattens three Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</PRE>
<DL>
<DD>Flattens four Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</PRE>
<DL>
<DD>Flattens five Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</PRE>
<DL>
<DD>Flattens six Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</PRE>
<DL>
<DD>Flattens seven Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</PRE>
<DL>
<DD>Flattens eight Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged<DD><CODE>t8</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</PRE>
<DL>
<DD>Flattens nine Observables into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged<DD><CODE>t8</CODE> - an Observable to be merged<DD><CODE>t9</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable[])"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;[]&nbsp;sequences)</PRE>
<DL>
<DD>Flattens an Array of Observables into one Observable, without any transformation.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.io.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Array of Observables
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the Observables in the Array<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable[], rx.Scheduler)"><!-- --></A><H3>
merge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;[]&nbsp;sequences,
                                            <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Flattens an Array of Observables into one Observable, without any transformation, traversing the array on
 a specified Scheduler.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.ios.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequences</CODE> - the Array of Observables<DD><CODE>scheduler</CODE> - the Scheduler on which to traverse the Array
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the Observables in the Array<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229061.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
 receive all successfully emitted items from all of the source Observables without being interrupted by
 an error notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable)"><CODE>Observable.merge(Observable)</CODE></A> except that if any of the merged Observables notify of an
 error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>, <code>mergeDelayError</code> will refrain from propagating that
 error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - an Observable that emits Observables
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the Observables emitted by the
         <code>source</code> Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2)</PRE>
<DL>
<DD>Flattens two Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from each of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable)</CODE></A> except that if any of the merged Observables
 notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>, <code>mergeDelayError</code> will refrain from
 propagating that error notification until all of the merged Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if both merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the two source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3)</PRE>
<DL>
<DD>Flattens three Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable)</CODE></A> except that if any of the merged
 Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>, <code>mergeDelayError</code> will refrain
 from propagating that error notification until all of the merged Observables have finished emitting
 items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4)</PRE>
<DL>
<DD>Flattens four Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable)</CODE></A> except that if any of
 the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>, <code>mergeDelayError</code>
 will refrain from propagating that error notification until all of the merged Observables have finished
 emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5)</PRE>
<DL>
<DD>Flattens five Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable, Observable)</CODE></A> except that
 if any of the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6)</PRE>
<DL>
<DD>Flattens six Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable, Observable, Observable)</CODE></A>
 except that if any of the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7)</PRE>
<DL>
<DD>Flattens seven Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like
 <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable)</CODE></A>
 except that if any of the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8)</PRE>
<DL>
<DD>Flattens eight Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)</CODE></A>
 except that if any of the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged<DD><CODE>t8</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t4,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t5,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t6,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t7,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t8,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;t9)</PRE>
<DL>
<DD>Flattens nine Observables into one Observable, in a way that allows an Observer to receive all
 successfully emitted items from all of the source Observables without being interrupted by an error
 notification from one of them.
 <p>
 This behaves like <A HREF="../rx/Observable.html#merge(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable)"><CODE>Observable.merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)</CODE></A>
 except that if any of the merged Observables notify of an error via <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>,
 <code>mergeDelayError</code> will refrain from propagating that error notification until all of the merged
 Observables have finished emitting items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png">
 <p>
 Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only
 invoke the <code>onError</code> method of its Observers once.
 <p>
 <code>mergeDelayError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged<DD><CODE>t2</CODE> - an Observable to be merged<DD><CODE>t3</CODE> - an Observable to be merged<DD><CODE>t4</CODE> - an Observable to be merged<DD><CODE>t5</CODE> - an Observable to be merged<DD><CODE>t6</CODE> - an Observable to be merged<DD><CODE>t7</CODE> - an Observable to be merged<DD><CODE>t8</CODE> - an Observable to be merged<DD><CODE>t9</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items that are emitted by the source Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#mergedelayerror">RxJava Wiki: mergeDelayError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="nest()"><!-- --></A><H3>
nest</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>nest</B>()</PRE>
<DL>
<DD>Converts the source <code>Observable&lt;T&gt;</code> into an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> that emits the
 source Observable as its single emission.
 <p>
 <img width="640" height="350" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/nest.png">
 <p>
 <code>nest</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a single item: the source Observable<DT><B>Since:</B></DT>
  <DD>0.17</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="never()"><!-- --></A><H3>
never</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>never</B>()</PRE>
<DL>
<DD>Returns an Observable that never sends any items or notifications to an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>.
 <p>
 <img width="640" height="185" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/never.png">
 <p>
 This Observable is useful primarily for testing purposes.
 <p>
 <code>never</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items (not) emitted by the Observable
<DT><B>Returns:</B><DD>an Observable that never emits any items or sends any notifications to an <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#empty-error-and-never">RxJava Wiki: never()</a></DL>
</DD>
</DL>
<HR>

<A NAME="parallelMerge(rx.Observable, int)"><!-- --></A><H3>
parallelMerge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt; <B>parallelMerge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source,
                                                                int&nbsp;parallelObservables)</PRE>
<DL>
<DD>Converts an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> into another <code>Observable&lt;Observable&lt;T&gt;&gt;</code> whose
 emitted Observables emit the same items as those emitted by the source Observable, but where the number
 of such Observables is restricted by <code>parallelObservables</code>.
 <p>
 For example, if the original <code>Observable&lt;Observable&lt;T&gt;&gt;</code> emits 100 Observables and
 <code>parallelObservables</code> is 8, the items emitted by the 100 original Observables will be distributed
 among 8 Observables emitted by the resulting Observable.
 <p>
 <img width="640" height="535" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/parallelMerge.png">
 <p>
 This is a mechanism for efficiently processing <i>n</i> number of Observables on a smaller <i>m</i>
 number of resources (typically CPU cores).
 <p>
 <code>parallelMerge</code> by default operates on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parallelObservables</CODE> - the number of Observables to merge into
<DT><B>Returns:</B><DD>an Observable of Observables constrained in number by <code>parallelObservables</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#parallelmerge">RxJava Wiki: parallelMerge()</a></DL>
</DD>
</DL>
<HR>

<A NAME="parallelMerge(rx.Observable, int, rx.Scheduler)"><!-- --></A><H3>
parallelMerge</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt; <B>parallelMerge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source,
                                                                int&nbsp;parallelObservables,
                                                                <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Converts an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> into another <code>Observable&lt;Observable&lt;T&gt;&gt;</code> whose
 emitted Observables emit the same items as those emitted by the source Observable, but where the number
 of such Observables is restricted by <code>parallelObservables</code>, and each runs on a defined Scheduler.
 <p>
 For example, if the original <code>Observable&lt;Observable&lt;T&gt;&gt;</code> emits 100 Observables and
 <code>parallelObservables</code> is 8, the items emitted by the 100 original Observables will be distributed
 among 8 Observables emitted by the resulting Observable.
 <p>
 <img width="640" height="535" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/parallelMerge.png">
 <p>
 This is a mechanism for efficiently processing <i>n</i> number of Observables on a smaller <i>m</i>
 number of resources (typically CPU cores).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parallelObservables</CODE> - the number of Observables to merge into<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to run each Observable on
<DT><B>Returns:</B><DD>an Observable of Observables constrained in number by <code>parallelObservables</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#parallelmerge">RxJava Wiki: parallelMerge()</a></DL>
</DD>
</DL>
<HR>

<A NAME="pivot(rx.Observable)"><!-- --></A><H3>
pivot</H3>
<PRE>
public static final &lt;K1,K2,T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K2,<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K1,T&gt;&gt;&gt; <B>pivot</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K1,<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K2,T&gt;&gt;&gt;&nbsp;groups)</PRE>
<DL>
<DD>Pivots a sequence of <code>GroupedObservable</code>s emitted by an <code>Observable</code> so as to swap the group
 and and the set on which their items are grouped.
 <p>
 <img width="640" height="580" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/pivot.png">

 For example an <code>Observable</code> such as this =&gt;
 
 <code>Observable&lt;GroupedObservable&lt;String, GroupedObservable&lt;Boolean, Integer&gt;&gt;&gt;</code>:
 <ul>
 <li>o1.odd: 1, 3, 5, 7, 9 on Thread 1</li>
 <li>o1.even: 2, 4, 6, 8, 10 on Thread 1</li>
 <li>o2.odd: 11, 13, 15, 17, 19 on Thread 2</li>
 <li>o2.even: 12, 14, 16, 18, 20 on Thread 2</li>
 </ul>
 is pivoted to become this =&gt;
 
 <code>Observable&lt;GroupedObservable&lt;Boolean, GroupedObservable&lt;String, Integer&gt;&gt;&gt;</code>:
 <ul>
 <li>odd.o1: 1, 3, 5, 7, 9 on Thread 1</li>
 <li>odd.o2: 11, 13, 15, 17, 19 on Thread 2</li>
 <li>even.o1: 2, 4, 6, 8, 10 on Thread 1</li>
 <li>even.o2: 12, 14, 16, 18, 20 on Thread 2</li>
 </ul>
 <p>
 <img width="640" height="1140" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/pivot.ex.png">
 <p>
 <em>Note:</em> A <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <A HREF="../rx/Observable.html#take(int)"><CODE>Observable.take(int)</CODE></A><code>(0)</code> to them.
 <p>
 <code>pivot</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>groups</CODE> - the <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A> to pivot
<DT><B>Returns:</B><DD>an <code>Observable</code> containing a stream of nested <code>GroupedObservable</code>s with swapped
         inner-outer keys.<DT><B>Since:</B></DT>
  <DD>0.17</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="range(int, int)"><!-- --></A><H3>
range</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt; <B>range</B>(int&nbsp;start,
                                                        int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits a sequence of Integers within a specified range.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/range.png">
 <p>
 <code>range</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - the value of the first Integer in the sequence<DD><CODE>count</CODE> - the number of sequential Integers to generate
<DT><B>Returns:</B><DD>an Observable that emits a range of sequential Integers
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>count</code> is less than zero, or if <code>start</code> + <code>count</code> &minus; 1 exceeds
             <code>Integer.MAX_VALUE</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#range">RxJava Wiki: range()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229460.aspx">MSDN: Observable.Range</a></DL>
</DD>
</DL>
<HR>

<A NAME="range(int, int, rx.Scheduler)"><!-- --></A><H3>
range</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt; <B>range</B>(int&nbsp;start,
                                                        int&nbsp;count,
                                                        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a sequence of Integers within a specified range, on a specified
 Scheduler.
 <p>
 <img width="640" height="195" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/range.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - the value of the first Integer in the sequence<DD><CODE>count</CODE> - the number of sequential Integers to generate<DD><CODE>scheduler</CODE> - the Scheduler to run the generator loop on
<DT><B>Returns:</B><DD>an Observable that emits a range of sequential Integers<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#range">RxJava Wiki: range()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211896.aspx">MSDN: Observable.Range</a></DL>
</DD>
</DL>
<HR>

<A NAME="sequenceEqual(rx.Observable, rx.Observable)"><!-- --></A><H3>
sequenceEqual</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>sequenceEqual</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;first,
                                                                    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;second)</PRE>
<DL>
<DD>Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sequenceEqual.png">
 <p>
 <code>sequenceEqual</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items emitted by each Observable<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first Observable to compare<DD><CODE>second</CODE> - the second Observable to compare
<DT><B>Returns:</B><DD>an Observable that emits a Boolean value that indicates whether the two sequences are the same<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#sequenceequal">RxJava Wiki: sequenceEqual()</a></DL>
</DD>
</DL>
<HR>

<A NAME="sequenceEqual(rx.Observable, rx.Observable, rx.functions.Func2)"><!-- --></A><H3>
sequenceEqual</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>sequenceEqual</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;first,
                                                                    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&nbsp;second,
                                                                    <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T,? super T,java.lang.Boolean&gt;&nbsp;equality)</PRE>
<DL>
<DD>Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
 same by comparing the items emitted by each Observable pairwise based on the results of a specified
 equality function.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sequenceEqual.png">
 <p>
 <code>sequenceEqual</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items emitted by each Observable<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first Observable to compare<DD><CODE>second</CODE> - the second Observable to compare<DD><CODE>equality</CODE> - a function used to compare items emitted by each Observable
<DT><B>Returns:</B><DD>an Observable that emits a Boolean value that indicates whether the two Observable two sequences
         are the same according to the specified function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#sequenceequal">RxJava Wiki: sequenceEqual()</a></DL>
</DD>
</DL>
<HR>

<A NAME="switchOnNext(rx.Observable)"><!-- --></A><H3>
switchOnNext</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>switchOnNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;sequenceOfSequences)</PRE>
<DL>
<DD>Converts an Observable that emits Observables into an Observable that emits the items emitted by the
 most recently emitted of those Observables.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/switchDo.png">
 <p>
 <code>switchOnNext</code> subscribes to an Observable that emits Observables. Each time it observes one of
 these emitted Observables, the Observable returned by <code>switchOnNext</code> begins emitting the items
 emitted by that Observable. When a new Observable is emitted, <code>switchOnNext</code> stops emitting items
 from the earlier-emitted Observable and begins emitting items from the new one.
 <p>
 <code>switchOnNext</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the item type<DT><B>Parameters:</B><DD><CODE>sequenceOfSequences</CODE> - the source Observable that emits Observables
<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the Observable most recently emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#switchonnext">RxJava Wiki: switchOnNext()</a></DL>
</DD>
</DL>
<HR>

<A NAME="timer(long, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
timer</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>timer</B>(long&nbsp;initialDelay,
                                                     long&nbsp;period,
                                                     java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.p.png">
 <p>
 <code>timer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialDelay</CODE> - the initial delay time to wait before emitting the first value of 0L<DD><CODE>period</CODE> - the period of time between emissions of the subsequent numbers<DD><CODE>unit</CODE> - the time unit for both <code>initialDelay</code> and <code>period</code>
<DT><B>Returns:</B><DD>an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
         each <code>period</code> of time thereafter<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer">RxJava Wiki: timer()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229435.aspx">MSDN: Observable.Timer</a></DL>
</DD>
</DL>
<HR>

<A NAME="timer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
timer</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>timer</B>(long&nbsp;initialDelay,
                                                     long&nbsp;period,
                                                     java.util.concurrent.TimeUnit&nbsp;unit,
                                                     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a <code>0L</code> after the <code>initialDelay</code> and ever increasing numbers
 after each <code>period</code> of time thereafter, on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.ps.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialDelay</CODE> - the initial delay time to wait before emitting the first value of 0L<DD><CODE>period</CODE> - the period of time between emissions of the subsequent numbers<DD><CODE>unit</CODE> - the time unit for both <code>initialDelay</code> and <code>period</code><DD><CODE>scheduler</CODE> - the Scheduler on which the waiting happens and items are emitted
<DT><B>Returns:</B><DD>an Observable that emits a 0L after the <code>initialDelay</code> and ever increasing numbers after
         each <code>period</code> of time thereafter, while running on the given Scheduler<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer">RxJava Wiki: timer()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229652.aspx">MSDN: Observable.Timer</a></DL>
</DD>
</DL>
<HR>

<A NAME="timer(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
timer</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>timer</B>(long&nbsp;delay,
                                                     java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits one item after a specified delay, and then completes.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.png">
 <p>
 <code>timer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the initial delay before emitting a single <code>0L</code><DD><CODE>unit</CODE> - time units to use for <code>delay</code>
<DT><B>Returns:</B><DD>an Observable that emits one item after a specified delay, and then completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer">RxJava wiki: timer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="timer(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
timer</H3>
<PRE>
public static final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>timer</B>(long&nbsp;delay,
                                                     java.util.concurrent.TimeUnit&nbsp;unit,
                                                     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits one item after a specified delay, on a specified Scheduler, and then
 completes.
 <p>
 <img width="640" height="200" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the initial delay before emitting a single 0L<DD><CODE>unit</CODE> - time units to use for <code>delay</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use for scheduling the item
<DT><B>Returns:</B><DD>an Observable that emits one item after a specified delay, on a specified Scheduler, and then
         completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer">RxJava wiki: timer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="using(rx.functions.Func0, rx.functions.Func1)"><!-- --></A><H3>
using</H3>
<PRE>
public static final &lt;T,Resource extends <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>using</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;Resource&gt;&nbsp;resourceFactory,
                                                                          <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;Resource,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T&gt;&gt;&nbsp;observableFactory)</PRE>
<DL>
<DD>Constructs an Observable that creates a dependent resource object.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/using.png">
 <p>
 <code>using</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resourceFactory</CODE> - the factory function to create a resource object that depends on the Observable<DD><CODE>observableFactory</CODE> - the factory function to create an Observable
<DT><B>Returns:</B><DD>the Observable whose lifetime controls the lifetime of the dependent resource object<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#using">RxJava Wiki: using()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229585.aspx">MSDN: Observable.Using</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(java.lang.Iterable, rx.functions.FuncN)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(java.lang.Iterable&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;?&gt;&gt;&nbsp;ws,
                                          <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 items emitted, in sequence, by an Iterable of other Observables.
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each of the source Observables;
 the second item emitted by the new Observable will be the result of the function applied to the second
 item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <code>onNext</code> as many times as
 the number of <code>onNext</code> invokations of the source Observable that emits the fewest items.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ws</CODE> - an Iterable of source Observables<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.functions.FuncN)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;?&gt;&gt;&nbsp;ws,
                                          <A HREF="../rx/functions/FuncN.html" title="interface in rx.functions">FuncN</A>&lt;? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 <i>n</i> items emitted, in sequence, by the <i>n</i> Observables emitted by a specified Observable.
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each of the Observables emitted
 by the source Observable; the second item emitted by the new Observable will be the result of the
 function applied to the second item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <code>onNext</code> as many times as
 the number of <code>onNext</code> invokations of the source Observable that emits the fewest items.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.o.png">
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ws</CODE> - an Observable of source Observables<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the Observables emitted by
            <code>ws</code>, results in an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.functions.Func2)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super T1,? super T2,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 two items emitted, in sequence, by two other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code> and the first item
 emitted by <code>o2</code>; the second item emitted by the new Observable will be the result of the function
 applied to the second item emitted by <code>o1</code> and the second item emitted by <code>o2</code>; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results
            in an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.functions.Func3)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                   <A HREF="../rx/functions/Func3.html" title="interface in rx.functions">Func3</A>&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 three items emitted, in sequence, by three other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, and the first item emitted by <code>o3</code>; the second item emitted by the new
 Observable will be the result of the function applied to the second item emitted by <code>o1</code>, the
 second item emitted by <code>o2</code>, and the second item emitted by <code>o3</code>; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func4)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                      <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                      <A HREF="../rx/functions/Func4.html" title="interface in rx.functions">Func4</A>&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 four items emitted, in sequence, by four other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, the first item emitted by <code>o3</code>, and the first item emitted by <code>04</code>;
 the second item emitted by the new Observable will be the result of the function applied to the second
 item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func5)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                         <A HREF="../rx/functions/Func5.html" title="interface in rx.functions">Func5</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 five items emitted, in sequence, by five other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by <code>o1</code>, the first item
 emitted by <code>o2</code>, the first item emitted by <code>o3</code>, the first item emitted by <code>o4</code>, and
 the first item emitted by <code>o5</code>; the second item emitted by the new Observable will be the result of
 the function applied to the second item emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>o5</CODE> - a fifth source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func6)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                            <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                            <A HREF="../rx/functions/Func6.html" title="interface in rx.functions">Func6</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 six items emitted, in sequence, by six other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>o5</CODE> - a fifth source Observable<DD><CODE>o6</CODE> - a sixth source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func7)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                               <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                               <A HREF="../rx/functions/Func7.html" title="interface in rx.functions">Func7</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 seven items emitted, in sequence, by seven other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>o5</CODE> - a fifth source Observable<DD><CODE>o6</CODE> - a sixth source Observable<DD><CODE>o7</CODE> - a seventh source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func8)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,T8,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
                                                                  <A HREF="../rx/functions/Func8.html" title="interface in rx.functions">Func8</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 eight items emitted, in sequence, by eight other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>o5</CODE> - a fifth source Observable<DD><CODE>o6</CODE> - a sixth source Observable<DD><CODE>o7</CODE> - a seventh source Observable<DD><CODE>o8</CODE> - an eighth source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.functions.Func9)"><!-- --></A><H3>
zip</H3>
<PRE>
public static final &lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T1&gt;&nbsp;o1,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;o2,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T3&gt;&nbsp;o3,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T4&gt;&nbsp;o4,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T5&gt;&nbsp;o5,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T6&gt;&nbsp;o6,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T7&gt;&nbsp;o7,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T8&gt;&nbsp;o8,
                                                                     <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T9&gt;&nbsp;o9,
                                                                     <A HREF="../rx/functions/Func9.html" title="interface in rx.functions">Func9</A>&lt;? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a function of your choosing applied to combinations of
 nine items emitted, in sequence, by nine other Observables.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> applies this function in strict sequence, so the first item emitted by the new Observable
 will be the result of the function applied to the first item emitted by each source Observable, the
 second item emitted by the new Observable will be the result of the function applied to the second item
 emitted by each of those Observables, and so forth.
 <p>
 The resulting <code>Observable&lt;R&gt;</code> returned from <code>zip</code> will invoke <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A>
 as many times as the number of <code>onNext</code> invocations of the source Observable that emits the fewest
 items.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o1</CODE> - the first source Observable<DD><CODE>o2</CODE> - a second source Observable<DD><CODE>o3</CODE> - a third source Observable<DD><CODE>o4</CODE> - a fourth source Observable<DD><CODE>o5</CODE> - a fifth source Observable<DD><CODE>o6</CODE> - a sixth source Observable<DD><CODE>o7</CODE> - a seventh source Observable<DD><CODE>o8</CODE> - an eighth source Observable<DD><CODE>o9</CODE> - a ninth source Observable<DD><CODE>zipFunction</CODE> - a function that, when applied to an item emitted by each of the source Observables, results in
            an item that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the zipped results<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#zip">RxJava Wiki: zip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="all(rx.functions.Func1)"><!-- --></A><H3>
all</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>all</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits a Boolean that indicates whether all of the items emitted by the source
 Observable satisfy a condition.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/all.png">
 <p>
 <code>all</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function that evaluates an item and returns a Boolean
<DT><B>Returns:</B><DD>an Observable that emits <code>true</code> if all items emitted by the source Observable satisfy the
         predicate; otherwise, <code>false</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#all">RxJava Wiki: all()</a></DL>
</DD>
</DL>
<HR>

<A NAME="ambWith(rx.Observable)"><!-- --></A><H3>
ambWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>ambWith</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</PRE>
<DL>
<DD>Mirrors the first Observable (current or provided) that emits an item.
 <p>
 <img width="640" height="385" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
 <p>
 <code>amb</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable competing to react first
<DT><B>Returns:</B><DD>an Observable that emits the same sequence of items as whichever of the source Observables first
         emitted an item<DT><B>Since:</B></DT>
  <DD>0.20</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava Wiki: amb()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229733.aspx">MSDN: Observable.Amb</a></DL>
</DD>
</DL>
<HR>

<A NAME="asObservable()"><!-- --></A><H3>
asObservable</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>asObservable</B>()</PRE>
<DL>
<DD>Disguises a object of an Observable subclass as a simple Observable object. Useful for instance when you
 have an implementation of a subclass of Observable but you want to hide the properties and methods of
 this subclass from whomever you are passing the Observable to.
 <p>
 <code>asObservable</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that hides the identity of this Observable</DL>
</DD>
</DL>
<HR>

<A NAME="buffer(rx.functions.Func0)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final &lt;TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;bufferClosingSelector)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
 new buffer whenever the Observable produced by the specified <code>bufferClosingSelector</code> emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer1.png">
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferClosingSelector</CODE> - a <A HREF="../rx/functions/Func0.html" title="interface in rx.functions"><CODE>Func0</CODE></A> that produces an Observable that governs the boundary between buffers.
            Whenever this <code>Observable</code> emits an item, <code>buffer</code> emits the current buffer and
            begins to fill a new one
<DT><B>Returns:</B><DD>an Observable that emits a connected, non-overlapping buffer of items from the source Observable
         each time the Observable created with the <code>bufferClosingSelector</code> argument emits an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(int)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer3.png">
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum number of items in each buffer before it should be emitted
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping buffers, each containing at most
         <code>count</code> items from the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(int, int)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(int&nbsp;count,
                                                  int&nbsp;skip)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits buffers every <code>skip</code> items, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer4.png">
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum size of each buffer before it should be emitted<DD><CODE>skip</CODE> - how many items emitted by the source Observable should be skipped before starting a new
            buffer. Note that when <code>skip</code> and <code>count</code> are equal, this is the same operation as
            <A HREF="../rx/Observable.html#buffer(int)"><CODE>Observable.buffer(int)</CODE></A>.
<DT><B>Returns:</B><DD>an Observable that emits buffers for every <code>skip</code> item from the source Observable and
         containing at most <code>count</code> items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  long&nbsp;timeshift,
                                                  java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable starts a new buffer periodically, as determined by the <code>timeshift</code> argument. It emits
 each buffer after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or encounters an error, the resulting Observable emits the current buffer and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer7.png">
 <p>
 This version of <code>buffer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted<DD><CODE>timeshift</CODE> - the period of time after which a new buffer will be created<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
<DT><B>Returns:</B><DD>an Observable that emits new buffers of items emitted by the source Observable periodically after
         a fixed timespan has elapsed<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  long&nbsp;timeshift,
                                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable starts a new buffer periodically, as determined by the <code>timeshift</code> argument, and on the
 specified <code>scheduler</code>. It emits each buffer after a fixed timespan, specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer7.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted<DD><CODE>timeshift</CODE> - the period of time after which a new buffer will be created<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a buffer
<DT><B>Returns:</B><DD>an Observable that emits new buffers of items emitted by the source Observable periodically after
         a fixed timespan has elapsed<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer5.png">
 <p>
 This version of <code>buffer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted and replaced with a new
            buffer<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> argument
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping buffers of items emitted by the source
         Observable within a fixed duration<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, java.util.concurrent.TimeUnit, int)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                                  int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument or a maximum size specified by the <code>count</code> argument (whichever is reached
 first). When the source Observable completes or encounters an error, the resulting Observable emits the
 current buffer and propagates the notification from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer6.png">
 <p>
 This version of <code>buffer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted and replaced with a new
            buffer<DD><CODE>unit</CODE> - the unit of time which applies to the <code>timespan</code> argument<DD><CODE>count</CODE> - the maximum size of each buffer before it is emitted
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping buffers of items emitted by the source
         Observable, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
         first)<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                                  int&nbsp;count,
                                                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument as measured on the specified <code>scheduler</code>, or a maximum size specified by
 the <code>count</code> argument (whichever is reached first). When the source Observable completes or
 encounters an error, the resulting Observable emits the current buffer and propagates the notification
 from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer6.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted and replaced with a new
            buffer<DD><CODE>unit</CODE> - the unit of time which applies to the <code>timespan</code> argument<DD><CODE>count</CODE> - the maximum size of each buffer before it is emitted<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a buffer
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping buffers of items emitted by the source
         Observable after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
         first)<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(long&nbsp;timespan,
                                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
 <code>timespan</code> argument and on the specified <code>scheduler</code>. When the source Observable completes or
 encounters an error, the resulting Observable emits the current buffer and propagates the notification
 from the source Observable.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer5.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each buffer collects items before it is emitted and replaced with a new
            buffer<DD><CODE>unit</CODE> - the unit of time which applies to the <code>timespan</code> argument<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a buffer
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping buffers of items emitted by the source
         Observable within a fixed duration<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(rx.Observable, rx.functions.Func1)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final &lt;TOpening,TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TOpening&gt;&nbsp;bufferOpenings,
                                                                      <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super TOpening,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;bufferClosingSelector)</PRE>
<DL>
<DD>Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
 Observable emits buffers that it creates when the specified <code>bufferOpenings</code> Observable emits an
 item, and closes when the Observable returned from <code>bufferClosingSelector</code> emits an item.
 <p>
 <img width="640" height="470" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer2.png">
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferOpenings</CODE> - the Observable that, when it emits an item, causes a new buffer to be created<DD><CODE>bufferClosingSelector</CODE> - the <A HREF="../rx/functions/Func1.html" title="interface in rx.functions"><CODE>Func1</CODE></A> that is used to produce an Observable for every buffer created. When this
            Observable emits an item, the associated buffer is emitted.
<DT><B>Returns:</B><DD>an Observable that emits buffers, containing items from the source Observable, that are created
         and closed when the specified Observables emit items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(rx.Observable)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final &lt;B&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;B&gt;&nbsp;boundary)</PRE>
<DL>
<DD>Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer8.png">
 <p>
 Completion of either the source or the boundary Observable causes the returned Observable to emit the
 latest buffer and complete.
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>B</CODE> - the boundary value type (ignored)<DT><B>Parameters:</B><DD><CODE>boundary</CODE> - the boundary Observable
<DT><B>Returns:</B><DD>an Observable that emits buffered items from the source Observable when the boundary Observable
         emits an item<DT><B>See Also:</B><DD><A HREF="../rx/Observable.html#buffer(rx.Observable, int)"><CODE>Observable.buffer(rx.Observable, int)</CODE></A>, 
<a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(rx.Observable, int)"><!-- --></A><H3>
buffer</H3>
<PRE>
public final &lt;B&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>buffer</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;B&gt;&nbsp;boundary,
                                                      int&nbsp;initialCapacity)</PRE>
<DL>
<DD>Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
 specified boundary Observable emits an item.
 <p>
 <img width="640" height="395" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/buffer8.png">
 <p>
 Completion of either the source or the boundary Observable causes the returned Observable to emit the
 latest buffer and complete.
 <p>
 This version of <code>buffer</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>B</CODE> - the boundary value type (ignored)<DT><B>Parameters:</B><DD><CODE>boundary</CODE> - the boundary Observable<DD><CODE>initialCapacity</CODE> - the initial capacity of each buffer chunk
<DT><B>Returns:</B><DD>an Observable that emits buffered items from the source Observable when the boundary Observable
         emits an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#buffer">RxJava Wiki: buffer()</a>, 
<A HREF="../rx/Observable.html#buffer(rx.Observable, int)"><CODE>Observable.buffer(rx.Observable, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cache()"><!-- --></A><H3>
cache</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>cache</B>()</PRE>
<DL>
<DD>Caches the emissions from the source Observable and replays them in order to any subsequent Subscribers.
 This method has similar behavior to <A HREF="../rx/Observable.html#replay()"><CODE>Observable.replay()</CODE></A> except that this auto-subscribes to the source
 Observable rather than returning a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> for which you must call
 <code>connect</code> to activate the subscription.
 <p>
 <img width="640" height="410" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/cache.png">
 <p>
 This is useful when you want an Observable to cache responses and you can't control the
 subscribe/unsubscribe behavior of all the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A>s.
 <p>
 When you call <code>cache</code>, it does not yet subscribe to the source Observable and so does not yet
 begin cacheing items. This only happens when the first Subscriber calls the resulting Observable's
 <code>subscribe</code> method.
 <p>

 <!-- IS THE FOLLOWING NOTE STILL VALID??? -->

 <em>Note:</em> You sacrifice the ability to unsubscribe from the origin when you use the <code>cache</code>
 Observer so be careful not to use this Observer on Observables that emit an infinite or very large number
 of items that will use up memory.
 <p>
 <code>cache</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that, when first subscribed to, caches all of its items and notifications for the
         benefit of subsequent subscribers<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache">RxJava Wiki: cache()</a></DL>
</DD>
</DL>
<HR>

<A NAME="cast(java.lang.Class)"><!-- --></A><H3>
cast</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>cast</B>(java.lang.Class&lt;R&gt;&nbsp;klass)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by the source Observable, converted to the specified
 type.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/cast.png">
 <p>
 <code>cast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>klass</CODE> - the target class type that <code>cast</code> will cast the items emitted by the source Observable
            into before emitting them from the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits each item from the source Observable after converting it to the
         specified type<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#cast">RxJava Wiki: cast()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211842.aspx">MSDN: Observable.Cast</a></DL>
</DD>
</DL>
<HR>

<A NAME="collect(java.lang.Object,rx.functions.Action2)"><!-- --></A><A NAME="collect(R, rx.functions.Action2)"><!-- --></A><H3>
collect</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>collect</B>(R&nbsp;state,
                                       <A HREF="../rx/functions/Action2.html" title="interface in rx.functions">Action2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;collector)</PRE>
<DL>
<DD>Collects items emitted by the source Observable into a single mutable data structure and returns an
 Observable that emits this structure.
 <p>
 <img width="640" height="330" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/collect.png">
 <p>
 This is a simplified version of <code>reduce</code> that does not need to return the state on each pass.
 <p>
 <code>collect</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>state</CODE> - the mutable data structure that will collect the items<DD><CODE>collector</CODE> - a function that accepts the <code>state</code> and an emitted item, and modifies <code>state</code>
           accordingly
<DT><B>Returns:</B><DD>an Observable that emits the result of collecting the values emitted by the source Observable
         into a single mutable data structure</DL>
</DD>
</DL>
<HR>

<A NAME="concatMap(rx.functions.Func1)"><!-- --></A><H3>
concatMap</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>concatMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Returns a new Observable that emits items resulting from applying a function that you supply to each item
 emitted by the source Observable, where that function returns an Observable, and then emitting the items
 that result from concatinating those resulting Observables.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concatMap.png">
 <p>
 <code>concatMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a function that, when applied to an item emitted by the source Observable, returns an
            Observable
<DT><B>Returns:</B><DD>an Observable that emits the result of applying the transformation function to each item emitted
         by the source Observable and concatinating the Observables obtained from this transformation</DL>
</DD>
</DL>
<HR>

<A NAME="concatWith(rx.Observable)"><!-- --></A><H3>
concatWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>concatWith</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted from the current Observable, then the next, one after
 the other, without interleaving them.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
 <p>
 <code>concat</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be concatenated after the current
<DT><B>Returns:</B><DD>an Observable that emits items emitted by the two source Observables, one after the other,
         without interleaving them<DT><B>Since:</B></DT>
  <DD>0.20</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat">RxJava Wiki: concat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx">MSDN: Observable.Concat</a></DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.lang.Object)"><!-- --></A><H3>
contains</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>contains</B>(java.lang.Object&nbsp;element)</PRE>
<DL>
<DD>Returns an Observable that emits a Boolean that indicates whether the source Observable emitted a
 specified item.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/contains.png">
 <p>
 <code>contains</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>element</CODE> - the item to search for in the emissions from the source Observable
<DT><B>Returns:</B><DD>an Observable that emits <code>true</code> if the specified item is emitted by the source Observable,
         or <code>false</code> if the source Observable completes without emitting that item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#contains">RxJava Wiki: contains()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh228965.aspx">MSDN: Observable.Contains</a></DL>
</DD>
</DL>
<HR>

<A NAME="count()"><!-- --></A><H3>
count</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Integer&gt; <B>count</B>()</PRE>
<DL>
<DD>Returns an Observable that emits the count of the total number of items emitted by the source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">
 <p>
 <code>count</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a single item: the number of elements emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#count-and-longcount">RxJava Wiki: count()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229470.aspx">MSDN: Observable.Count</a>, 
<A HREF="../rx/Observable.html#longCount()"><CODE>Observable.longCount()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="debounce(rx.functions.Func1)"><!-- --></A><H3>
debounce</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>debounce</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;debounceSelector)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by another item within a computed debounce duration.
 <p>
 <img width="640" height="425" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/debounce.f.png">
 <p>
 This version of <code>debounce</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the debounce value type (ignored)<DT><B>Parameters:</B><DD><CODE>debounceSelector</CODE> - function to retrieve a sequence that indicates the throttle duration for each item
<DT><B>Returns:</B><DD>an Observable that omits items emitted by the source Observable that are followed by another item
         within a computed debounce duration</DL>
</DD>
</DL>
<HR>

<A NAME="debounce(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
debounce</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>debounce</B>(long&nbsp;timeout,
                                    java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires. The timer resets on
 each emission.
 <p>
 <em>Note:</em> If items keep being emitted by the source Observable faster than the timeout then no items
 will be emitted by the resulting Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/debounce.png">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <p>
 This version of <code>debounce</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the time each item has to be "the most recent" of those emitted by the source Observable to
            ensure that it's not dropped<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> for the timeout
<DT><B>Returns:</B><DD>an Observable that filters out items from the source Observable that are too quickly followed by
         newer items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlewithtimeout-or-debounce">RxJava Wiki: debounce()</a>, 
<A HREF="../rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleWithTimeout(long, TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="debounce(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
debounce</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>debounce</B>(long&nbsp;timeout,
                                    java.util.concurrent.TimeUnit&nbsp;unit,
                                    <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
 source Observable that are followed by newer items before a timeout value expires on a specified
 Scheduler. The timer resets on each emission.
 <p>
 <em>Note:</em> If items keep being emitted by the source Observable faster than the timeout then no items
 will be emitted by the resulting Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/debounce.s.png">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the time each item has to be "the most recent" of those emitted by the source Observable to
            ensure that it's not dropped<DD><CODE>unit</CODE> - the unit of time for the specified timeout<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use internally to manage the timers that handle the timeout for each
            item
<DT><B>Returns:</B><DD>an Observable that filters out items from the source Observable that are too quickly followed by
         newer items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlewithtimeout-or-debounce">RxJava Wiki: debounce()</a>, 
<A HREF="../rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><CODE>Observable.throttleWithTimeout(long, TimeUnit, Scheduler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defaultIfEmpty(java.lang.Object)"><!-- --></A><A NAME="defaultIfEmpty(T)"><!-- --></A><H3>
defaultIfEmpty</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>defaultIfEmpty</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by the source Observable or a specified default item
 if the source Observable is empty.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/defaultIfEmpty.png">
 <p>
 <code>defaultIfEmpty</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - the item to emit if the source Observable emits no items
<DT><B>Returns:</B><DD>an Observable that emits either the specified default item if the source Observable emits no
         items, or the items emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#defaultifempty">RxJava Wiki: defaultIfEmpty()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229624.aspx">MSDN: Observable.DefaultIfEmpty</a></DL>
</DD>
</DL>
<HR>

<A NAME="delay(rx.functions.Func0, rx.functions.Func1)"><!-- --></A><H3>
delay</H3>
<PRE>
public final &lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delay</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;subscriptionDelay,
                                       <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;itemDelay)</PRE>
<DL>
<DD>Returns an Observable that delays the subscription to and emissions from the souce Observable via another
 Observable on a per-item basis.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.oo.png">
 <p>
 <em>Note:</em> the resulting Observable will immediately propagate any <code>onError</code> notification
 from the source Observable.
 <p>
 This version of <code>delay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the subscription delay value type (ignored)<DD><CODE>V</CODE> - the item delay value type (ignored)<DT><B>Parameters:</B><DD><CODE>subscriptionDelay</CODE> - a function that returns an Observable that triggers the subscription to the source Observable
            once it emits any item<DD><CODE>itemDelay</CODE> - a function that returns an Observable for each item emitted by the source Observable, which is
            then used to delay the emission of that item by the resulting Observable until the Observable
            returned from <code>itemDelay</code> emits an item
<DT><B>Returns:</B><DD>an Observable that delays the subscription and emissions of the source Observable via another
         Observable on a per-item basis</DL>
</DD>
</DL>
<HR>

<A NAME="delay(rx.functions.Func1)"><!-- --></A><H3>
delay</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;itemDelay)</PRE>
<DL>
<DD>Returns an Observable that delays the emissions of the source Observable via another Observable on a
 per-item basis.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.o.png">
 <p>
 <em>Note:</em> the resulting Observable will immediately propagate any <code>onError</code> notification
 from the source Observable.
 <p>
 This version of <code>delay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the item delay value type (ignored)<DT><B>Parameters:</B><DD><CODE>itemDelay</CODE> - a function that returns an Observable for each item emitted by the source Observable, which is
            then used to delay the emission of that item by the resulting Observable until the Observable
            returned from <code>itemDelay</code> emits an item
<DT><B>Returns:</B><DD>an Observable that delays the emissions of the source Observable via another Observable on a
         per-item basis</DL>
</DD>
</DL>
<HR>

<A NAME="delay(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
delay</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delay</B>(long&nbsp;delay,
                                 java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay. Error notifications from the source Observable are not delayed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.png">
 <p>
 This version of <code>delay</code> operates by default on the <code>compuation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the delay to shift the source by<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> in which <code>period</code> is defined
<DT><B>Returns:</B><DD>the source Observable shifted in time by the specified delay<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#delay">RxJava Wiki: delay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229810.aspx">MSDN: Observable.Delay</a></DL>
</DD>
</DL>
<HR>

<A NAME="delay(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
delay</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delay</B>(long&nbsp;delay,
                                 java.util.concurrent.TimeUnit&nbsp;unit,
                                 <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
 specified delay. Error notifications from the source Observable are not delayed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the delay to shift the source by<DD><CODE>unit</CODE> - the time unit of <code>delay</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use for delaying
<DT><B>Returns:</B><DD>the source Observable shifted in time by the specified delay<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#delay">RxJava Wiki: delay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229280.aspx">MSDN: Observable.Delay</a></DL>
</DD>
</DL>
<HR>

<A NAME="delaySubscription(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
delaySubscription</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delaySubscription</B>(long&nbsp;delay,
                                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that delays the subscription to the source Observable by a given amount of time.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delaySubscription.png">
 <p>
 This version of <code>delay</code> operates by default on the <code>compuation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the time to delay the subscription<DD><CODE>unit</CODE> - the time unit of <code>delay</code>
<DT><B>Returns:</B><DD>an Observable that delays the subscription to the source Observable by the given amount</DL>
</DD>
</DL>
<HR>

<A NAME="delaySubscription(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
delaySubscription</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>delaySubscription</B>(long&nbsp;delay,
                                             java.util.concurrent.TimeUnit&nbsp;unit,
                                             <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that delays the subscription to the source Observable by a given amount of time,
 both waiting and subscribing on a given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delaySubscription.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>delay</CODE> - the time to delay the subscription<DD><CODE>unit</CODE> - the time unit of <code>delay</code><DD><CODE>scheduler</CODE> - the Scheduler on which the waiting and subscription will happen
<DT><B>Returns:</B><DD>an Observable that delays the subscription to the source Observable by a given
         amount, waiting and subscribing on the given Scheduler</DL>
</DD>
</DL>
<HR>

<A NAME="dematerialize()"><!-- --></A><H3>
dematerialize</H3>
<PRE>
public final &lt;T2&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt; <B>dematerialize</B>()</PRE>
<DL>
<DD>Returns an Observable that reverses the effect of <A HREF="../rx/Observable.html#materialize()"><CODE>materialize</CODE></A> by transforming the
 <A HREF="../rx/Notification.html" title="class in rx"><CODE>Notification</CODE></A> objects emitted by the source Observable into the items or notifications they
 represent.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/dematerialize.png">
 <p>
 <code>dematerialize</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits the items and notifications embedded in the <A HREF="../rx/Notification.html" title="class in rx"><CODE>Notification</CODE></A> objects
         emitted by the source Observable
<DT><B>Throws:</B>
<DD><CODE><A HREF="../rx/exceptions/OnErrorNotImplementedException.html" title="class in rx.exceptions">OnErrorNotImplementedException</A></CODE> - if the source Observable is not of type <code>Observable&lt;Notification&lt;T&gt;&gt;</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dematerialize">RxJava Wiki: dematerialize()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229047.aspx">MSDN: Observable.dematerialize</a></DL>
</DD>
</DL>
<HR>

<A NAME="distinct()"><!-- --></A><H3>
distinct</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>distinct</B>()</PRE>
<DL>
<DD>Returns an Observable that emits all items emitted by the source Observable that are distinct.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.png">
 <p>
 <code>distinct</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits only those items emitted by the source Observable that are distinct from
         each other<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#distinct">RxJava Wiki: distinct()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229764.aspx">MSDN: Observable.distinct</a></DL>
</DD>
</DL>
<HR>

<A NAME="distinct(rx.functions.Func1)"><!-- --></A><H3>
distinct</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>distinct</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends U&gt;&nbsp;keySelector)</PRE>
<DL>
<DD>Returns an Observable that emits all items emitted by the source Observable that are distinct according
 to a key selector function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.key.png">
 <p>
 <code>distinct</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - a function that projects an emitted item to a key value that is used to decide whether an item
            is distinct from another one or not
<DT><B>Returns:</B><DD>an Observable that emits those items emitted by the source Observable that have distinct keys<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#distinct">RxJava Wiki: distinct()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244310.aspx">MSDN: Observable.distinct</a></DL>
</DD>
</DL>
<HR>

<A NAME="distinctUntilChanged()"><!-- --></A><H3>
distinctUntilChanged</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>distinctUntilChanged</B>()</PRE>
<DL>
<DD>Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.png">
 <p>
 <code>distinctUntilChanged</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits those items from the source Observable that are distinct from their
         immediate predecessors<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#distinctuntilchanged">RxJava Wiki: distinctUntilChanged()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229494.aspx">MSDN: Observable.distinctUntilChanged</a></DL>
</DD>
</DL>
<HR>

<A NAME="distinctUntilChanged(rx.functions.Func1)"><!-- --></A><H3>
distinctUntilChanged</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>distinctUntilChanged</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends U&gt;&nbsp;keySelector)</PRE>
<DL>
<DD>Returns an Observable that emits all items emitted by the source Observable that are distinct from their
 immediate predecessors, according to a key selector function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.key.png">
 <p>
 <code>distinctUntilChanged</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - a function that projects an emitted item to a key value that is used to decide whether an item
            is distinct from another one or not
<DT><B>Returns:</B><DD>an Observable that emits those items from the source Observable whose keys are distinct from
         those of their immediate predecessors<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#distinctuntilchanged">RxJava Wiki: distinctUntilChanged()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229508.aspx">MSDN: Observable.distinctUntilChanged</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnCompleted(rx.functions.Action0)"><!-- --></A><H3>
doOnCompleted</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnCompleted</B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onCompleted)</PRE>
<DL>
<DD>Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnCompleted.png">
 <p>
 <code>doOnCompleted</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onCompleted</CODE> - the action to invoke when the source Observable calls <code>onCompleted</code>
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooncompleted">RxJava Wiki: doOnCompleted()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnEach(rx.functions.Action1)"><!-- --></A><H3>
doOnEach</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnEach</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;onNotification)</PRE>
<DL>
<DD>Modifies the source Observable so that it invokes an action for each item it emits.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnEach.png">
 <p>
 <code>doOnEach</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNotification</CODE> - the action to invoke for each item emitted by the source Observable
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229307.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnEach(rx.Observer)"><!-- --></A><H3>
doOnEach</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnEach</B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</PRE>
<DL>
<DD>Modifies the source Observable so that it notifies an Observer for each item it emits.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnEach.png">
 <p>
 <code>doOnEach</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>observer</CODE> - the action to invoke for each item emitted by the source Observable
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnEach()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229307.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnError(rx.functions.Action1)"><!-- --></A><H3>
doOnError</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnError</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</PRE>
<DL>
<DD>Modifies the source Observable so that it invokes an action if it calls <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnError.png">
 <p>
 <code>doOnError</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onError</CODE> - the action to invoke if the source Observable calls <code>onError</code>
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#doonerror">RxJava Wiki: doOnError()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnNext(rx.functions.Action1)"><!-- --></A><H3>
doOnNext</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnNext</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</PRE>
<DL>
<DD>Modifies the source Observable so that it invokes an action when it calls <code>onNext</code>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnNext.png">
 <p>
 <code>doOnNext</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - the action to invoke when the source Observable calls <code>onNext</code>
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#dooneach">RxJava Wiki: doOnNext()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="doOnTerminate(rx.functions.Action0)"><!-- --></A><H3>
doOnTerminate</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>doOnTerminate</B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onTerminate)</PRE>
<DL>
<DD>Modifies the source Observable so that it invokes an action when it calls <code>onCompleted</code> or
 <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnTerminate.png">
 <p>
 This differs from <code>finallyDo</code> in that this happens <em>before</em> the <code>onCompleted</code> or
 <code>onError</code> notification.
 <p>
 <code>doOnTerminate</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onTerminate</CODE> - the action to invoke when the source Observable calls <code>onCompleted</code> or <code>onError</code>
<DT><B>Returns:</B><DD>the source Observable with the side-effecting behavior applied<DT><B>Since:</B></DT>
  <DD>0.17</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#doonterminate">RxJava Wiki: doOnTerminate()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229804.aspx">MSDN: Observable.Do</a></DL>
</DD>
</DL>
<HR>

<A NAME="elementAt(int)"><!-- --></A><H3>
elementAt</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>elementAt</B>(int&nbsp;index)</PRE>
<DL>
<DD>Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
 source Observbable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAt.png">
 <p>
 <code>elementAt</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the zero-based index of the item to retrieve
<DT><B>Returns:</B><DD>an Observable that emits a single item: the item at the specified position in the sequence of
         those emitted by the source Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>index</code> is greater than or equal to the number of items emitted by the source
             Observable, or
             if <code>index</code> is less than 0<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#elementat">RxJava Wiki: elementAt()</a></DL>
</DD>
</DL>
<HR>

<A NAME="elementAtOrDefault(int,java.lang.Object)"><!-- --></A><A NAME="elementAtOrDefault(int, T)"><!-- --></A><H3>
elementAtOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>elementAtOrDefault</B>(int&nbsp;index,
                                              <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</PRE>
<DL>
<DD>Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
 source Observable, or a default item if that index is out of range.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAtOrDefault.png">
 <p>
 <code>elementAtOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the zero-based index of the item to retrieve<DD><CODE>defaultValue</CODE> - the default item
<DT><B>Returns:</B><DD>an Observable that emits the item at the specified position in the sequence emitted by the source
         Observable, or the default item if that index is outside the bounds of the source sequence
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>index</code> is less than 0<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#elementatordefault">RxJava Wiki: elementAtOrDefault()</a></DL>
</DD>
</DL>
<HR>

<A NAME="exists(rx.functions.Func1)"><!-- --></A><H3>
exists</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>exists</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits <code>true</code> if any item emitted by the source Observable satisfies a
 specified condition, otherwise <code>false</code>. <em>Note:</em> this always emits <code>false</code> if the
 source Observable is empty.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/exists.png">
 <p>
 In Rx.Net this is the <code>any</code> Observer but we renamed it in RxJava to better match Java naming
 idioms.
 <p>
 <code>exists</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the condition to test items emitted by the source Observable
<DT><B>Returns:</B><DD>an Observable that emits a Boolean that indicates whether any item emitted by the source
         Observable satisfies the <code>predicate</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#exists-and-isempty">RxJava Wiki: exists()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211993.aspx">MSDN: Observable.Any (Note: the description in this page was wrong at the time of this writing)</a></DL>
</DD>
</DL>
<HR>

<A NAME="filter(rx.functions.Func1)"><!-- --></A><H3>
filter</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>filter</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Filters items emitted by an Observable by only emitting those that satisfy a specified predicate.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/filter.png">
 <p>
 <code>filter</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function that evaluates each item emitted by the source Observable, returning <code>true</code>
            if it passes the filter
<DT><B>Returns:</B><DD>an Observable that emits only those items emitted by the source Observable that the filter
         evaluates as <code>true</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#filter-or-where">RxJava Wiki: filter()</a></DL>
</DD>
</DL>
<HR>

<A NAME="finallyDo(rx.functions.Action0)"><!-- --></A><H3>
finallyDo</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>finallyDo</B>(<A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;action)</PRE>
<DL>
<DD>Registers an <A HREF="../rx/functions/Action0.html" title="interface in rx.functions"><CODE>Action0</CODE></A> to be called when this Observable invokes either
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> or <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A>.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/finallyDo.png">
 <p>
 <code>finallyDo</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>action</CODE> - an <A HREF="../rx/functions/Action0.html" title="interface in rx.functions"><CODE>Action0</CODE></A> to be invoked when the source Observable finishes
<DT><B>Returns:</B><DD>an Observable that emits the same items as the source Observable, then invokes the
         <A HREF="../rx/functions/Action0.html" title="interface in rx.functions"><CODE>Action0</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#finallydo">RxJava Wiki: finallyDo()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212133.aspx">MSDN: Observable.Finally</a></DL>
</DD>
</DL>
<HR>

<A NAME="first()"><!-- --></A><H3>
first</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>first</B>()</PRE>
<DL>
<DD>Returns an Observable that emits only the very first item emitted by the source Observable, or notifies
 of an <code>NoSuchElementException</code> if the source Observable is empty.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">
 <p>
 <code>first</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits only the very first item emitted by the source Observable, or raises an
         <code>NoSuchElementException</code> if the source Observable is empty<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#first">RxJava Wiki: first()</a>, 
"MSDN: Observable.firstAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="first(rx.functions.Func1)"><!-- --></A><H3>
first</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>first</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or notifies of an <code>NoSuchElementException</code> if no such items are emitted.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstN.png">
 <p>
 <code>first</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the condition that an item emitted by the source Observable has to satisfy
<DT><B>Returns:</B><DD>an Observable that emits only the very first item emitted by the source Observable that satisfies
         the <code>predicate</code>, or raises an <code>NoSuchElementException</code> if no such items are emitted<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#first">RxJava Wiki: first()</a>, 
"MSDN: Observable.firstAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="firstOrDefault(java.lang.Object)"><!-- --></A><A NAME="firstOrDefault(T)"><!-- --></A><H3>
firstOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>firstOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</PRE>
<DL>
<DD>Returns an Observable that emits only the very first item emitted by the source Observable, or a default
 item if the source Observable completes without emitting anything.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">
 <p>
 <code>firstOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - the default item to emit if the source Observable doesn't emit anything
<DT><B>Returns:</B><DD>an Observable that emits only the very first item from the source, or a default item if the
         source Observable completes without emitting any items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#firstordefault">RxJava Wiki: firstOrDefault()</a>, 
"MSDN: Observable.firstOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="firstOrDefault(java.lang.Object,rx.functions.Func1)"><!-- --></A><A NAME="firstOrDefault(T, rx.functions.Func1)"><!-- --></A><H3>
firstOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>firstOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
                                          <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition, or a default item if the source Observable emits no such items.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefaultN.png">
 <p>
 <code>firstOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the condition any item emitted by the source Observable has to satisfy<DD><CODE>defaultValue</CODE> - the default item to emit if the source Observable doesn't emit anything that satisfies the
            <code>predicate</code>
<DT><B>Returns:</B><DD>an Observable that emits only the very first item emitted by the source Observable that satisfies
         the <code>predicate</code>, or a default item if the source Observable emits no such items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#firstordefault">RxJava Wiki: firstOrDefault()</a>, 
"MSDN: Observable.firstOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="flatMap(rx.functions.Func1)"><!-- --></A><H3>
flatMap</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>flatMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Returns an Observable that emits items based on applying a function that you supply to each item emitted
 by the source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png">
 <p>
 <code>flatMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a function that, when applied to an item emitted by the source Observable, returns an
            Observable
<DT><B>Returns:</B><DD>an Observable that emits the result of applying the transformation function to each item emitted
         by the source Observable and merging the results of the Observables obtained from this
         transformation<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#mapmany-or-flatmap-and-mapmanydelayerror">RxJava Wiki: flatMap()</a></DL>
</DD>
</DL>
<HR>

<A NAME="forEach(rx.functions.Action1)"><!-- --></A><H3>
forEach</H3>
<PRE>
public final void <B>forEach</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</PRE>
<DL>
<DD>Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element.
 <p>
 Alias to <A HREF="../rx/Observable.html#subscribe(rx.functions.Action1)"><CODE>Observable.subscribe(Action1)</CODE></A>
 <p>
 <code>forEach</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - <A HREF="../rx/functions/Action1.html" title="interface in rx.functions"><CODE>Action1</CODE></A> to execute for each item.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null, or
             if <code>onError</code> is null, or
             if <code>onComplete</code> is null<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="forEach(rx.functions.Action1, rx.functions.Action1)"><!-- --></A><H3>
forEach</H3>
<PRE>
public final void <B>forEach</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                          <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</PRE>
<DL>
<DD>Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element and error events.
 <p>
 Alias to <A HREF="../rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1)"><CODE>Observable.subscribe(Action1, Action1)</CODE></A>
 <p>
 <code>forEach</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - <A HREF="../rx/functions/Action1.html" title="interface in rx.functions"><CODE>Action1</CODE></A> to execute for each item.<DD><CODE>onError</CODE> - <A HREF="../rx/functions/Action1.html" title="interface in rx.functions"><CODE>Action1</CODE></A> to execute when an error is emitted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null, or
             if <code>onError</code> is null, or
             if <code>onComplete</code> is null<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="forEach(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0)"><!-- --></A><H3>
forEach</H3>
<PRE>
public final void <B>forEach</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                          <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError,
                          <A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onComplete)</PRE>
<DL>
<DD>Subscribes to the <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and receives notifications for each element and the terminal events.
 <p>
 Alias to <A HREF="../rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0)"><CODE>Observable.subscribe(Action1, Action1, Action0)</CODE></A>
 <p>
 <code>forEach</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - <A HREF="../rx/functions/Action1.html" title="interface in rx.functions"><CODE>Action1</CODE></A> to execute for each item.<DD><CODE>onError</CODE> - <A HREF="../rx/functions/Action1.html" title="interface in rx.functions"><CODE>Action1</CODE></A> to execute when an error is emitted.<DD><CODE>onComplete</CODE> - <A HREF="../rx/functions/Action0.html" title="interface in rx.functions"><CODE>Action0</CODE></A> to execute when completion is signalled.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null, or
             if <code>onError</code> is null, or
             if <code>onComplete</code> is null<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="groupBy(rx.functions.Func1)"><!-- --></A><H3>
groupBy</H3>
<PRE>
public final &lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;K,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>groupBy</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</PRE>
<DL>
<DD>Groups the items emitted by an <code>Observable</code> according to a specified criterion, and emits these
 grouped items as <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s, one <code>GroupedObservable</code> per group.
 <p>
 <img width="640" height="360" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupBy.png">
 <p>
 <em>Note:</em> A <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <A HREF="../rx/Observable.html#take(int)"><CODE>Observable.take(int)</CODE></A><code>(0)</code> to them.
 <p>
 <code>groupBy</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>K</CODE> - the key type<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - a function that extracts the key for each item
<DT><B>Returns:</B><DD>an <code>Observable</code> that emits <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s, each of which corresponds to a
         unique key value and each of which emits those items from the source Observable that share that
         key value<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava Wiki: groupBy</a></DL>
</DD>
</DL>
<HR>

<A NAME="groupByUntil(rx.functions.Func1, rx.functions.Func1)"><!-- --></A><H3>
groupByUntil</H3>
<PRE>
public final &lt;TKey,TDuration&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>groupByUntil</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TKey&gt;&nbsp;keySelector,
                                                                                 <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TDuration&gt;&gt;&nbsp;durationSelector)</PRE>
<DL>
<DD>Groups the items emitted by an <code>Observable</code> according to a specified key selector function until
 the duration <code>Observable</code> expires for the key.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupByUntil.png">
 <p>
 <em>Note:</em> A <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <A HREF="../rx/Observable.html#take(int)"><CODE>Observable.take(int)</CODE></A><code>(0)</code> to them.
 <p>
 <code>groupByUntil</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - a function to extract the key for each item<DD><CODE>durationSelector</CODE> - a function to signal the expiration of a group
<DT><B>Returns:</B><DD>an <code>Observable</code> that emits <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s, each of which corresponds to a key
         value and each of which emits all items emitted by the source <code>Observable</code> during that
         key's duration that share that same key value<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava Wiki: groupByUntil()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211932.aspx">MSDN: Observable.GroupByUntil</a></DL>
</DD>
</DL>
<HR>

<A NAME="groupByUntil(rx.functions.Func1, rx.functions.Func1, rx.functions.Func1)"><!-- --></A><H3>
groupByUntil</H3>
<PRE>
public final &lt;TKey,TValue,TDuration&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,TValue&gt;&gt; <B>groupByUntil</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TKey&gt;&nbsp;keySelector,
                                                                                             <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TValue&gt;&nbsp;valueSelector,
                                                                                             <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables">GroupedObservable</A>&lt;TKey,TValue&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TDuration&gt;&gt;&nbsp;durationSelector)</PRE>
<DL>
<DD>Groups the items emitted by an <code>Observable</code> (transformed by a selector) according to a specified
 key selector function until the duration Observable expires for the key.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupByUntil.png">
 <p>
 <em>Note:</em> A <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A> will cache the items it is to emit until such time as it
 is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
 <code>GroupedObservable</code>s that do not concern you. Instead, you can signal to them that they may
 discard their buffers by applying an operator like <A HREF="../rx/Observable.html#take(int)"><CODE>Observable.take(int)</CODE></A><code>(0)</code> to them.
 <p>
 <code>groupByUntil</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - a function to extract the key for each item<DD><CODE>valueSelector</CODE> - a function to map each item emitted by the source <code>Observable</code> to an item emitted by one
            of the resulting <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s<DD><CODE>durationSelector</CODE> - a function to signal the expiration of a group
<DT><B>Returns:</B><DD>an <code>Observable</code> that emits <A HREF="../rx/observables/GroupedObservable.html" title="class in rx.observables"><CODE>GroupedObservable</CODE></A>s, each of which corresponds to a key
         value and each of which emits all items emitted by the source <code>Observable</code> during that
         key's duration that share that same key value, transformed by the value selector<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava Wiki: groupByUntil()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229433.aspx">MSDN: Observable.GroupByUntil</a></DL>
</DD>
</DL>
<HR>

<A NAME="groupJoin(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2)"><!-- --></A><H3>
groupJoin</H3>
<PRE>
public final &lt;T2,D1,D2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>groupJoin</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;right,
                                                  <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;D1&gt;&gt;&nbsp;leftDuration,
                                                  <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super T2,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;D2&gt;&gt;&nbsp;rightDuration,
                                                  <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;,? extends R&gt;&nbsp;resultSelector)</PRE>
<DL>
<DD>Returns an Observable that correlates two Observables when they overlap in time and groups the results.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/groupJoin.png">
 <p>
 <code>groupJoin</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>right</CODE> - the other Observable to correlate items from the source Observable with<DD><CODE>leftDuration</CODE> - a function that returns an Observable whose emissions indicate the duration of the values of
            the source Observable<DD><CODE>rightDuration</CODE> - a function that returns an Observable whose emissions indicate the duration of the values of
            the <code>right</code> Observable<DD><CODE>resultSelector</CODE> - a function that takes an item emitted by each Observable and returns the value to be emitted
            by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits items based on combining those items emitted by the source Observables
         whose durations overlap<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#join-and-groupjoin">RxJava Wiiki: groupJoin</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244235.aspx">MSDN: Observable.GroupJoin</a></DL>
</DD>
</DL>
<HR>

<A NAME="ignoreElements()"><!-- --></A><H3>
ignoreElements</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>ignoreElements</B>()</PRE>
<DL>
<DD>Ignores all items emitted by the source Observable and only calls <code>onCompleted</code> or <code>onError</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/ignoreElements.png">
 <p>
 <code>ignoreElements</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an empty Observable that only calls <code>onCompleted</code> or <code>onError</code>, based on which one is
         called by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#ignoreelements">RxJava Wiki: ignoreElements()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229242.aspx">MSDN: Observable.IgnoreElements</a></DL>
</DD>
</DL>
<HR>

<A NAME="isEmpty()"><!-- --></A><H3>
isEmpty</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Boolean&gt; <B>isEmpty</B>()</PRE>
<DL>
<DD>Returns an Observable that emits <code>true</code> if the source Observable is empty, otherwise <code>false</code>.
 <p>
 In Rx.Net this is negated as the <code>any</code> Observer but we renamed this in RxJava to better match Java
 naming idioms.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/isEmpty.png">
 <p>
 <code>isEmpty</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a Boolean<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#exists-and-isempty">RxJava Wiki: isEmpty()</a>, 
<a href= "http://msdn.microsoft.com/en-us/library/hh229905.aspx">MSDN: Observable.Any</a></DL>
</DD>
</DL>
<HR>

<A NAME="join(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2)"><!-- --></A><H3>
join</H3>
<PRE>
public final &lt;TRight,TLeftDuration,TRightDuration,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>join</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TRight&gt;&nbsp;right,
                                                                        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TLeftDuration&gt;&gt;&nbsp;leftDurationSelector,
                                                                        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;TRight,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TRightDuration&gt;&gt;&nbsp;rightDurationSelector,
                                                                        <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,TRight,R&gt;&nbsp;resultSelector)</PRE>
<DL>
<DD>Correlates the items emitted by two Observables based on overlapping durations.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/join_.png">
 <p>
 <code>join</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>right</CODE> - the second Observable to join items from<DD><CODE>leftDurationSelector</CODE> - a function to select a duration for each item emitted by the source Observable, used to
            determine overlap<DD><CODE>rightDurationSelector</CODE> - a function to select a duration for each item emitted by the <code>right</code> Observable, used to
            determine overlap<DD><CODE>resultSelector</CODE> - a function that computes an item to be emitted by the resulting Observable for any two
            overlapping items emitted by the two Observables
<DT><B>Returns:</B><DD>an Observable that emits items correlating to items emitted by the source Observables that have
         overlapping durations<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#join">RxJava Wiki: join()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229750.aspx">MSDN: Observable.Join</a></DL>
</DD>
</DL>
<HR>

<A NAME="last()"><!-- --></A><H3>
last</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>last</B>()</PRE>
<DL>
<DD>Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
 a <code>NoSuchElementException</code> if the source Observable is empty.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/last.png">
 <p>
 <code>last</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits the last item from the source Observable or notifies observers of an
         error<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observable-Operators#last">RxJava Wiki: last()</a>, 
"MSDN: Observable.lastAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="last(rx.functions.Func1)"><!-- --></A><H3>
last</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>last</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 given condition, or notifies of a <code>NoSuchElementException</code> if no such items are emitted.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/last.p.png">
 <p>
 <code>last</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the condition any source emitted item has to satisfy
<DT><B>Returns:</B><DD>an Observable that emits only the last item satisfying the given condition from the source, or an
         <code>NoSuchElementException</code> if no such items are emitted
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if no items that match the predicate are emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observable-Operators#last">RxJava Wiki: last()</a>, 
"MSDN: Observable.lastAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="lastOrDefault(java.lang.Object)"><!-- --></A><A NAME="lastOrDefault(T)"><!-- --></A><H3>
lastOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>lastOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</PRE>
<DL>
<DD>Returns an Observable that emits only the last item emitted by the source Observable, or a default item
 if the source Observable completes without emitting any items.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/lastOrDefault.png">
 <p>
 <code>lastOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - the default item to emit if the source Observable is empty
<DT><B>Returns:</B><DD>an Observable that emits only the last item emitted by the source Observable, or a default item
         if the source Observable is empty<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#lastOrDefault">RxJava Wiki: lastOrDefault()</a>, 
"MSDN: Observable.lastOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="lastOrDefault(java.lang.Object,rx.functions.Func1)"><!-- --></A><A NAME="lastOrDefault(T, rx.functions.Func1)"><!-- --></A><H3>
lastOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>lastOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
                                         <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
 specified condition, or a default item if no such item is emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/lastOrDefault.p.png">
 <p>
 <code>lastOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - the default item to emit if the source Observable doesn't emit anything that satisfies the
            specified <code>predicate</code><DD><CODE>predicate</CODE> - the condition any item emitted by the source Observable has to satisfy
<DT><B>Returns:</B><DD>an Observable that emits only the last item emitted by the source Observable that satisfies the
         given condition, or a default item if no such item is emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#lastOrDefault">RxJava Wiki: lastOrDefault()</a>, 
"MSDN: Observable.lastOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="limit(int)"><!-- --></A><H3>
limit</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>limit</B>(int&nbsp;num)</PRE>
<DL>
<DD>Returns an Observable that emits only the first <code>num</code> items emitted by the source Observable.
 <p>
 Alias of <A HREF="../rx/Observable.html#take(int)"><CODE>Observable.take(int)</CODE></A> to match Java 8 Stream API naming convention.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.png">
 <p>
 This method returns an Observable that will invoke a subscribing <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s
 <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> function a maximum of <code>num</code> times before invoking
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A>.
 <p>
 <code>limit</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>num</CODE> - the maximum number of items to emit
<DT><B>Returns:</B><DD>an Observable that emits only the first <code>num</code> items emitted by the source Observable, or
         all of the items from the source Observable if that Observable emits fewer than <code>num</code> items<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#take">RxJava Wiki: take()</a></DL>
</DD>
</DL>
<HR>

<A NAME="longCount()"><!-- --></A><H3>
longCount</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.lang.Long&gt; <B>longCount</B>()</PRE>
<DL>
<DD>Returns an Observable that counts the total number of items emitted by the source Observable and emits
 this count as a 64-bit Long.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/longCount.png">
 <p>
 <code>longCount</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a single item: the number of items emitted by the source Observable as a
         64-bit Long item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#count-and-longcount">RxJava Wiki: count()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229120.aspx">MSDN: Observable.LongCount</a>, 
<A HREF="../rx/Observable.html#count()"><CODE>Observable.count()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="map(rx.functions.Func1)"><!-- --></A><H3>
map</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>map</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends R&gt;&nbsp;func)</PRE>
<DL>
<DD>Returns an Observable that applies a specified function to each item emitted by the source Observable and
 emits the results of these function applications.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/map.png">
 <p>
 <code>map</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a function to apply to each item emitted by the Observable
<DT><B>Returns:</B><DD>an Observable that emits the items from the source Observable, transformed by the specified
         function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#map">RxJava Wiki: map()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244306.aspx">MSDN: Observable.Select</a></DL>
</DD>
</DL>
<HR>

<A NAME="materialize()"><!-- --></A><H3>
materialize</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>materialize</B>()</PRE>
<DL>
<DD>Returns an Observable that represents all of the emissions <em>and</em> notifications from the source
 Observable into emissions marked with their original types within <A HREF="../rx/Notification.html" title="class in rx"><CODE>Notification</CODE></A> objects.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/materialize.png">
 <p>
 <code>materialize</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits items that are the result of materializing the items and notifications
         of the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#materialize">RxJava Wiki: materialize()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229453.aspx">MSDN: Observable.materialize</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeMap(rx.functions.Func1)"><!-- --></A><H3>
mergeMap</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mergeMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Returns an Observable that emits the results of applying a specified function to each item emitted by the
 source Observable, where that function returns an Observable, and then merging those resulting
 Observables and emitting the results of this merger.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMap.png">
 <p>
 <code>mergeMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a function that, when applied to an item emitted by the source Observable, returns an
            Observable
<DT><B>Returns:</B><DD>an Observable that emits the result of applying the transformation function to each item emitted
         by the source Observable and merging the results of the Observables obtained from these
         transformations<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#mapmany-or-flatmap-and-mapmanydelayerror">RxJava Wiki: flatMap()</a>, 
<A HREF="../rx/Observable.html#flatMap(rx.functions.Func1)"><CODE>Observable.flatMap(Func1)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="mergeMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)"><!-- --></A><H3>
mergeMap</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mergeMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onNext,
                                        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onError,
                                        <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;onCompleted)</PRE>
<DL>
<DD>Returns an Observable that applies a function to each item emitted or notification raised by the source
 Observable and then flattens the Observables returned from these functions and emits the resulting items.
 <p>
 <img width="640" height="410" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMap.nce.png">
 <p>
 <code>mergeMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the result type<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - a function that returns an Observable to merge for each item emitted by the source Observable<DD><CODE>onError</CODE> - a function that returns an Observable to merge for an onError notification from the source
            Observable<DD><CODE>onCompleted</CODE> - a function that returns an Observable to merge for an onCompleted notification from the source
            Observable
<DT><B>Returns:</B><DD>an Observable that emits the results of merging the Observables returned from applying the
         specified functions to the emissions and notifications of the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="mergeMap(rx.functions.Func1, rx.functions.Func2)"><!-- --></A><H3>
mergeMap</H3>
<PRE>
public final &lt;U,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mergeMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends U&gt;&gt;&nbsp;collectionSelector,
                                          <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super U,? extends R&gt;&nbsp;resultSelector)</PRE>
<DL>
<DD>Returns an Observable that emits the results of a specified function to the pair of values emitted by the
 source Observable and a specified collection Observable.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMap.r.png">
 <p>
 <code>mergeMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the type of items emitted by the collection Observable<DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>collectionSelector</CODE> - a function that returns an Observable for each item emitted by the source Observable<DD><CODE>resultSelector</CODE> - a function that combines one item emitted by each of the source and collection Observables and
            returns an item to be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that emits the results of applying a function to a pair of values emitted by the
         source Observable and the collection Observable</DL>
</DD>
</DL>
<HR>

<A NAME="mergeMapIterable(rx.functions.Func1)"><!-- --></A><H3>
mergeMapIterable</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mergeMapIterable</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;collectionSelector)</PRE>
<DL>
<DD>Returns an Observable that merges each item emitted by the source Observable with the values in an
 Iterable corresponding to that item that is generated by a selector.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMapIterable.png">
 <p>
 <code>mergeMapIterable</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of item emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>collectionSelector</CODE> - a function that returns an Iterable sequence of values for when given an item emitted by the
            source Observable
<DT><B>Returns:</B><DD>an Observable that emits the results of merging the items emitted by the source Observable with
         the values in the Iterables corresponding to those items, as generated by <code>collectionSelector</code></DL>
</DD>
</DL>
<HR>

<A NAME="mergeMapIterable(rx.functions.Func1, rx.functions.Func2)"><!-- --></A><H3>
mergeMapIterable</H3>
<PRE>
public final &lt;U,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mergeMapIterable</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends java.lang.Iterable&lt;? extends U&gt;&gt;&nbsp;collectionSelector,
                                                  <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super U,? extends R&gt;&nbsp;resultSelector)</PRE>
<DL>
<DD>Returns an Observable that emits the results of applying a function to the pair of values from the source
 Observable and an Iterable corresponding to that item that is generated by a selector.
 <p>
 <img width="640" height="390" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMapIterable.r.png">
 <p>
 <code>mergeMapIterable</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the collection element type<DD><CODE>R</CODE> - the type of item emited by the resulting Observable<DT><B>Parameters:</B><DD><CODE>collectionSelector</CODE> - a function that returns an Iterable sequence of values for each item emitted by the source
            Observable<DD><CODE>resultSelector</CODE> - a function that returns an item based on the item emitted by the source Observable and the
            Iterable returned for that item by the <code>collectionSelector</code>
<DT><B>Returns:</B><DD>an Observable that emits the items returned by <code>resultSelector</code> for each item in the source
         Observable</DL>
</DD>
</DL>
<HR>

<A NAME="mergeWith(rx.Observable)"><!-- --></A><H3>
mergeWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>mergeWith</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;t1)</PRE>
<DL>
<DD>Flattens this and another Observable into a single Observable, without any transformation.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png">
 <p>
 You can combine items emitted by multiple Observables so that they appear as a single Observable, by
 using the <code>merge</code> method.
 <p>
 <code>merge</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - an Observable to be merged
<DT><B>Returns:</B><DD>an Observable that emits all of the items emitted by the source Observables<DT><B>Since:</B></DT>
  <DD>0.20</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#merge">RxJava Wiki: merge()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229099.aspx">MSDN: Observable.Merge</a></DL>
</DD>
</DL>
<HR>

<A NAME="multicast(rx.functions.Func0, rx.functions.Func1)"><!-- --></A><H3>
multicast</H3>
<PRE>
public final &lt;TIntermediate,TResult&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TResult&gt; <B>multicast</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends TIntermediate&gt;&gt;&nbsp;subjectFactory,
                                                                   <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TIntermediate&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;TResult&gt;&gt;&nbsp;selector)</PRE>
<DL>
<DD>Returns an Observable that emits items produced by multicasting the source Observable within a selector
 function.
 <p>
 This is largely a helper function used by RxJava for other forms of multicasting, such as
 <A HREF="../rx/Observable.html#publish()"><CODE>Observable.publish()</CODE></A> and <A HREF="../rx/Observable.html#publishLast()"><CODE>Observable.publishLast()</CODE></A>.
 <p>
 <code>multicast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>subjectFactory</CODE> - the <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects"><CODE>Subject</CODE></A> factory<DD><CODE>selector</CODE> - the selector function, which can use the multicasted source Observable subject to the policies
            enforced by the created <code>Subject</code>
<DT><B>Returns:</B><DD>an Observable that emits the items produced by multicasting the source Observable within a
         selector function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast">RxJava: Observable.publish() and Observable.multicast()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229708.aspx">MSDN: Observable.Multicast</a></DL>
</DD>
</DL>
<HR>

<A NAME="multicast(rx.subjects.Subject)"><!-- --></A><H3>
multicast</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;R&gt; <B>multicast</B>(<A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends R&gt;&nbsp;subject)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that upon connection causes the source Observable to push results
 into the specified subject. A Connectable Observable resembles an ordinary Observable, except that it
 does not begin emitting items when it is subscribed to, but only when its <code>connect()</code> method
 is called.
 <p>
 <code>multicast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting <code>ConnectableObservable</code><DT><B>Parameters:</B><DD><CODE>subject</CODE> - the <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects"><CODE>Subject</CODE></A> for the <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> to push source items into
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that upon connection causes the source Observable to push results
         into the specified <A HREF="../rx/subjects/Subject.html" title="class in rx.subjects"><CODE>Subject</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast">RxJava Wiki: Observable.publish() and Observable.multicast()</a></DL>
</DD>
</DL>
<HR>

<A NAME="observeOn(rx.Scheduler)"><!-- --></A><H3>
observeOn</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>observeOn</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Modifies an Observable to perform its emissions and notifications on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>,
 asynchronously with an unbounded buffer.
 <p>
 <img width="640" height="308" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/observeOn.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to notify <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s on
<DT><B>Returns:</B><DD>the source Observable modified so that its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s are notified on the specified
         <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#observeon">RxJava Wiki: observeOn()</a>, 
<a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>, 
<A HREF="../rx/Observable.html#subscribeOn(rx.Scheduler)"><CODE>Observable.subscribeOn(rx.Scheduler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ofType(java.lang.Class)"><!-- --></A><H3>
ofType</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>ofType</B>(java.lang.Class&lt;R&gt;&nbsp;klass)</PRE>
<DL>
<DD>Filters the items emitted by an Observable, only emitting those of the specified type.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/ofClass.png">
 <p>
 <code>ofType</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>klass</CODE> - the class type to filter the items emitted by the source Observable
<DT><B>Returns:</B><DD>an Observable that emits items from the source Observable of type <code>klass</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#oftype">RxJava Wiki: ofType()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229380.aspx">MSDN: Observable.OfType</a></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.functions.Func1)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorResumeNext</code> method changes this
 behavior. If you pass a function that returns an Observable (<code>resumeFunction</code>) to
 <code>onErrorResumeNext</code>, if the original Observable encounters an error, instead of invoking its
 Observer's <code>onError</code> method, it will instead relinquish control to the Observable returned from
 <code>resumeFunction</code>, which will invoke the Observer's <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> method if it is
 able to do so. In such a case, because no Observable necessarily invokes <code>onError</code>, the Observer
 may never know that an error happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <p>
 <code>onErrorResumeNext</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - a function that returns an Observable that will take over if the source Observable encounters
            an error
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onerrorresumenext">RxJava Wiki: onErrorResumeNext()</a></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.Observable)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</PRE>
<DL>
<DD>Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorResumeNext</code> method changes this
 behavior. If you pass another Observable (<code>resumeSequence</code>) to an Observable's
 <code>onErrorResumeNext</code> method, if the original Observable encounters an error, instead of invoking its
 Observer's <code>onError</code> method, it will instead relinquish control to <code>resumeSequence</code> which
 will invoke the Observer's <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> method if it is able to do so. In such a case,
 because no Observable necessarily invokes <code>onError</code>, the Observer may never know that an error
 happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <p>
 <code>onErrorResumeNext</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeSequence</CODE> - a function that returns an Observable that will take over if the source Observable encounters
            an error
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onerrorresumenext">RxJava Wiki: onErrorResumeNext()</a></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorReturn(rx.functions.Func1)"><!-- --></A><H3>
onErrorReturn</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorReturn</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;java.lang.Throwable,? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instructs an Observable to emit an item (returned by a specified function) rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an error.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorReturn.png">
 <p>
 By default, when an Observable encounters an error that prevents it from emitting the expected item to
 its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onErrorReturn</code> method changes this
 behavior. If you pass a function (<code>resumeFunction</code>) to an Observable's <code>onErrorReturn</code>
 method, if the original Observable encounters an error, instead of invoking its Observer's
 <code>onError</code> method, it will instead emit the return value of <code>resumeFunction</code>.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be
 encountered.
 <p>
 <code>onErrorReturn</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - a function that returns an item that the new Observable will emit if the source Observable
            encounters an error
<DT><B>Returns:</B><DD>the original Observable with appropriately modified behavior<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onerrorreturn">RxJava Wiki: onErrorReturn()</a></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorFlatMap(rx.functions.Func1)"><!-- --></A><H3>
onErrorFlatMap</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorFlatMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/exceptions/OnErrorThrowable.html" title="class in rx.exceptions">OnErrorThrowable</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Intercepts <code>onError</code> notifications from the source Observable and replaces them with the
 <code>onNext</code> emissions of an Observable returned by a specified function. This allows the source
 sequence to continue even if it issues multiple <code>onError</code> notifications.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorFlatMap.png">
 <p>
 <code>onErrorFlatMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - a function that accepts an <A HREF="../rx/exceptions/OnErrorThrowable.html" title="class in rx.exceptions"><CODE>OnErrorThrowable</CODE></A> representing the Throwable issued by the
            source Observable, and returns an Observable that emits items that will be emitted in place
            of the error
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior<DT><B>Since:</B></DT>
  <DD>0.17</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onerrorflatmap">RxJava Wiki: onErrorFlatMap()</a></DL>
</DD>
</DL>
<HR>

<A NAME="onExceptionResumeNext(rx.Observable)"><!-- --></A><H3>
onExceptionResumeNext</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onExceptionResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</PRE>
<DL>
<DD>Instructs an Observable to pass control to another Observable rather than invoking
 <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>onError</CODE></A> if it encounters an <CODE>Exception</CODE>.
 <p>
 This differs from <A HREF="../rx/Observable.html#onErrorResumeNext(rx.functions.Func1)"><CODE>Observable.onErrorResumeNext(rx.functions.Func1<java.lang.Throwable, ? extends rx.Observable<? extends T>>)</CODE></A> in that this one does not handle <CODE>Throwable</CODE>
 or <CODE>Error</CODE> but lets those continue through.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onExceptionResumeNextViaObservable.png">
 <p>
 By default, when an Observable encounters an exception that prevents it from emitting the expected item
 to its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>, the Observable invokes its Observer's <code>onError</code> method, and then quits
 without invoking any more of its Observer's methods. The <code>onExceptionResumeNext</code> method changes
 this behavior. If you pass another Observable (<code>resumeSequence</code>) to an Observable's
 <code>onExceptionResumeNext</code> method, if the original Observable encounters an exception, instead of
 invoking its Observer's <code>onError</code> method, it will instead relinquish control to
 <code>resumeSequence</code> which will invoke the Observer's <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> method if it is
 able to do so. In such a case, because no Observable necessarily invokes <code>onError</code>, the Observer
 may never know that an exception happened.
 <p>
 You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be
 encountered.
 <p>
 <code>onErrorResumeNext</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeSequence</CODE> - a function that returns an Observable that will take over if the source Observable encounters
            an exception
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#onexceptionresumenext">RxJava Wiki: onExceptionResumeNext()</a></DL>
</DD>
</DL>
<HR>

<A NAME="parallel(rx.functions.Func1)"><!-- --></A><H3>
parallel</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>parallel</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;f)</PRE>
<DL>
<DD>Performs work on the source Observable in parallel by sharding it on a <A HREF="../rx/schedulers/Schedulers.html#computation()"><CODE>Schedulers.computation()</CODE></A>
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, and returns the resulting Observable.
 <p>
 <img width="640" height="475" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/parallel.png">
 <p>
 <code>parallel</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - a <A HREF="../rx/functions/Func1.html" title="interface in rx.functions"><CODE>Func1</CODE></A> that applies Observable Observers to <code>Observable&lt;T&gt;</code> in parallel and
            returns an <code>Observable&lt;R&gt;</code>
<DT><B>Returns:</B><DD>an Observable that emits the results of applying <code>f</code> to the items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#parallel">RxJava Wiki: parallel()</a></DL>
</DD>
</DL>
<HR>

<A NAME="parallel(rx.functions.Func1, rx.Scheduler)"><!-- --></A><H3>
parallel</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>parallel</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;f,
                                        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;s)</PRE>
<DL>
<DD>Performs work on the source Observable<T> in parallel by sharding it on a <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, and returns
 the resulting Observable.
 <p>
 <img width="640" height="475" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/parallel.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - a <A HREF="../rx/functions/Func1.html" title="interface in rx.functions"><CODE>Func1</CODE></A> that applies Observable Observers to <code>Observable&lt;T&gt;</code> in parallel and
            returns an <code>Observable&lt;R&gt;</code><DD><CODE>s</CODE> - a <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to perform the work on
<DT><B>Returns:</B><DD>an Observable that emits the results of applying <code>f</code> to the items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#parallel">RxJava Wiki: parallel()</a></DL>
</DD>
</DL>
<HR>

<A NAME="publish()"><!-- --></A><H3>
publish</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>publish</B>()</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A>, which waits until its
 <A HREF="../rx/observables/ConnectableObservable.html#connect()"><CODE>connect</CODE></A> method is called before it begins emitting items to those
 <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s that have subscribed to it.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishConnect.png">
 <p>
 <code>publish</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that upon connection causes the source Observable to emit items
         to its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast">RxJava Wiki: publish()</a></DL>
</DD>
</DL>
<HR>

<A NAME="publish(rx.functions.Func1)"><!-- --></A><H3>
publish</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>publish</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</PRE>
<DL>
<DD>Returns an Observable that emits the results of invoking a specified selector on items emitted by a
 <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying sequence.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishConnect.f.png">
 <p>
 <code>publish</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a function that can use the multicasted source sequence as many times as needed, without
            causing multiple subscriptions to the source sequence. Subscribers to the given source will
            receive all notifications of the source from the time of the subscription forward.
<DT><B>Returns:</B><DD>an Observable that emits the results of invoking the selector on the items emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying sequence</DL>
</DD>
</DL>
<HR>

<A NAME="publish(rx.functions.Func1,java.lang.Object)"><!-- --></A><A NAME="publish(rx.functions.Func1, T)"><!-- --></A><H3>
publish</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>publish</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                       <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue)</PRE>
<DL>
<DD>Returns an Observable that emits <code>initialValue</code> followed by the results of invoking a specified
 selector on items emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the
 source Observable.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishConnect.if.png">
 <p>
 <code>publish</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a function that can use the multicasted source sequence as many times as needed, without
            causing multiple subscriptions to the source Observable. Subscribers to the source will
            receive all notifications of the source from the time of the subscription forward<DD><CODE>initialValue</CODE> - the initial value of the underlying <A HREF="../rx/subjects/BehaviorSubject.html" title="class in rx.subjects"><CODE>BehaviorSubject</CODE></A>
<DT><B>Returns:</B><DD>an Observable that emits <code>initialValue</code> followed by the results of invoking the selector
         on a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying Observable</DL>
</DD>
</DL>
<HR>

<A NAME="publish(java.lang.Object)"><!-- --></A><A NAME="publish(T)"><!-- --></A><H3>
publish</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>publish</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that emits <code>initialValue</code> followed by the items emitted by
 the source Observable. A Connectable Observable resembles an ordinary Observable, except that it does not
 begin emitting items when it is subscribed to, but only when its <code>connect()</code> method is called.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishConnect.i.png">
 <p>
 <code>publish</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - the initial value to be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying Observable
         and starts with <code>initialValue</code></DL>
</DD>
</DL>
<HR>

<A NAME="publishLast()"><!-- --></A><H3>
publishLast</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>publishLast</B>()</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that emits only the last item emitted by the source Observable.
 A Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items
 when it is subscribed to, but only when its <code>connect()</code> method is called. 
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishLast.png">
 <p>
 <code>publishLast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that emits only the last item emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablepublishlast">RxJava Wiki: publishLast()</a></DL>
</DD>
</DL>
<HR>

<A NAME="publishLast(rx.functions.Func1)"><!-- --></A><H3>
publishLast</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>publishLast</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</PRE>
<DL>
<DD>Returns an Observable that emits an item that results from invoking a specified selector on the last item
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishLast.f.png">
 <p>
 <code>publishLast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a function that can use the multicasted source sequence as many times as needed, without
            causing multiple subscriptions to the source Observable. Subscribers to the source will only
            receive the last item emitted by the source.
<DT><B>Returns:</B><DD>an Observable that emits an item that is the result of invoking the selector on a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>reduce</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 and emits the final result from the final call to your function as its sole item.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduce.png">
 <p>
 This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code> method
 that does a similar operation on lists.
 <p>
 <code>reduce</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - an accumulator function to be invoked on each item emitted by the source Observable, whose
            result will be used in the next accumulator call
<DT><B>Returns:</B><DD>an Observable that emits a single item that is the result of accumulating the items emitted by
         the source Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the source Observable emits no items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce">RxJava Wiki: reduce()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229154.aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(java.lang.Object,rx.functions.Func2)"><!-- --></A><A NAME="reduce(R, rx.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>reduce</B>(R&nbsp;initialValue,
                                      <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable and a specified seed value, then feeds the result of that function along with the second item
 emitted by an Observable into the same function, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your function as its sole item.
 <p>
 <img width="640" height="325" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduceSeed.png">
 <p>
 This technique, which is called "reduce" here, is sometimec called "aggregate," "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code> method
 that does a similar operation on lists.
 <p>
 <code>reduce</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - the initial (seed) accumulator value<DD><CODE>accumulator</CODE> - an accumulator function to be invoked on each item emitted by the source Observable, the
            result of which will be used in the next accumulator call
<DT><B>Returns:</B><DD>an Observable that emits a single item that is the result of accumulating the output from the
         items emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce">RxJava Wiki: reduce()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229154.aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="repeat()"><!-- --></A><H3>
repeat</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>repeat</B>()</PRE>
<DL>
<DD>Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely.
 <p>
 <img width="640" height="309" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/repeat.o.png">
 <p>
 <code>repeat</code> operates by default on the <code>trampoline</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the source Observable repeatedly and in sequence<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#repeat">RxJava Wiki: repeat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229428.aspx">MSDN: Observable.Repeat</a></DL>
</DD>
</DL>
<HR>

<A NAME="repeat(rx.Scheduler)"><!-- --></A><H3>
repeat</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>repeat</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely,
 on a particular Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/repeat.os.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the Scheduler to emit the items on
<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the source Observable repeatedly and in sequence<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#repeat">RxJava Wiki: repeat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229428.aspx">MSDN: Observable.Repeat</a></DL>
</DD>
</DL>
<HR>

<A NAME="repeat(long)"><!-- --></A><H3>
repeat</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>repeat</B>(long&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/repeat.on.png">
 <p>
 <code>repeat</code> operates by default on the <code>trampoline</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the number of times the source Observable items are repeated, a count of 0 will yield an empty
            sequence
<DT><B>Returns:</B><DD>an Observable that repeats the sequence of items emitted by the source Observable at most
         <code>count</code> times
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>count</code> is less than zero<DT><B>Since:</B></DT>
  <DD>0.17</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#repeat">RxJava Wiki: repeat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229428.aspx">MSDN: Observable.Repeat</a></DL>
</DD>
</DL>
<HR>

<A NAME="repeat(long, rx.Scheduler)"><!-- --></A><H3>
repeat</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>repeat</B>(long&nbsp;count,
                                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that repeats the sequence of items emitted by the source Observable at most
 <code>count</code> times, on a particular Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/repeat.ons.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the number of times the source Observable items are repeated, a count of 0 will yield an empty
            sequence<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to emit the items on
<DT><B>Returns:</B><DD>an Observable that repeats the sequence of items emitted by the source Observable at most
         <code>count</code> times on a particular Scheduler<DT><B>Since:</B></DT>
  <DD>0.17</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#repeat">RxJava Wiki: repeat()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229428.aspx">MSDN: Observable.Repeat</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay()"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>()</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the underlying Observable
 that will replay all of its items and notifications to any future <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>. A Connectable
 Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
 subscribed to, but only when its <code>connect()</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.png">
 <p>
 This version of <code>replay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that upon connection causes the source Observable to emit its
         items to its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on the items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.
 <p>
 <img width="640" height="450" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.f.png">
 <p>
 This version of <code>replay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - the selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on a
         <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229653.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, int)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      int&nbsp;bufferSize)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying <code>bufferSize</code> notifications.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fn.png">
 <p>
 This version of <code>replay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - the selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items the connectable observable can replay
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable
         replaying no more than <code>bufferSize</code> items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211675.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, int, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      int&nbsp;bufferSize,
                                      long&nbsp;time,
                                      java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.
 <p>
 <img width="640" height="445" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fnt.png">
 <p>
 This version of <code>replay</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items the connectable observable can replay<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable, and
         replays no more than <code>bufferSize</code> items that were emitted within the window defined by
         <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh228952.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, int, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      int&nbsp;bufferSize,
                                      long&nbsp;time,
                                      java.util.concurrent.TimeUnit&nbsp;unit,
                                      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying no more than <code>bufferSize</code> items that were emitted within a specified time window.
 <p>
 <img width="640" height="445" height="440" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fnts.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items the connectable observable can replay<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler that is the time source for the window
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable, and
         replays no more than <code>bufferSize</code> items that were emitted within the window defined by
         <code>time</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>bufferSize</code> is less than zero<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229404.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, int, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      int&nbsp;bufferSize,
                                      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying a maximum of <code>bufferSize</code> items.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fns.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items the connectable observable can replay<DD><CODE>scheduler</CODE> - the Scheduler on which the replay is observed
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
         replaying no more than <code>bufferSize</code> notifications<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229928.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      long&nbsp;time,
                                      java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.
 <p>
 <img width="640" height="435" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.ft.png">
 <p>
 This version of <code>replay</code> does operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
         replaying all items that were emitted within the window defined by <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229526.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      long&nbsp;time,
                                      java.util.concurrent.TimeUnit&nbsp;unit,
                                      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
 replaying all items that were emitted within a specified time window.
 <p>
 <img width="640" height="440" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fts.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the scheduler that is the time source for the window
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
         replaying all items that were emitted within the window defined by <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244327.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.functions.Func1, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>replay</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;selector,
                                      <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the results of invoking a specified selector on items
 emitted by a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable.
 <p>
 <img width="640" height="445" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.fs.png">
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>selector</CODE> - a selector function, which can use the multicasted sequence as many times as needed, without
            causing multiple subscriptions to the Observable<DD><CODE>scheduler</CODE> - the Scheduler where the replay is observed
<DT><B>Returns:</B><DD>an Observable that emits items that are the results of invoking the selector on items emitted by
         a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable,
         replaying all items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211644.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(int)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(int&nbsp;bufferSize)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable that
 replays at most <code>bufferSize</code> items emitted by that Observable. A Connectable Observable resembles
 an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
 when its <code>connect()</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.n.png">
 <p>
 This version of <code>replay</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items that can be replayed
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays at most <code>bufferSize</code> items emitted by that Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211976.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(int, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(int&nbsp;bufferSize,
                                             long&nbsp;time,
                                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items that were emitted during a specified time window. A Connectable
 Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
 subscribed to, but only when its <code>connect()</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.nt.png">
 <p>
 This version of <code>replay</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items that can be replayed<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays at most <code>bufferSize</code> items that were emitted during the window defined by
         <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229874.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(int&nbsp;bufferSize,
                                             long&nbsp;time,
                                             java.util.concurrent.TimeUnit&nbsp;unit,
                                             <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 that replays a maximum of <code>bufferSize</code> items that are emitted within a specified time window. A
 Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items
 when it is subscribed to, but only when its <code>connect()</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.nts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items that can be replayed<DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the scheduler that is used as a time source for the window
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays at most <code>bufferSize</code> items that were emitted during the window defined by
         <code>time</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>bufferSize</code> is less than zero<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211759.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(int, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(int&nbsp;bufferSize,
                                             <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays at most <code>bufferSize</code> items emitted by that Observable. A Connectable Observable resembles
 an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
 when its <code>connect()</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.ns.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bufferSize</CODE> - the buffer size that limits the number of items that can be replayed<DD><CODE>scheduler</CODE> - the scheduler on which the Observers will observe the emitted items
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays at most <code>bufferSize</code> items that were emitted by the Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229814.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(long&nbsp;time,
                                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window. A Connectable Observable
 resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
 but only when its <code>connect()</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.t.png">
 <p>
 This version of <code>replay</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays the items that were emitted during the window defined by <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229232.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(long&nbsp;time,
                                             java.util.concurrent.TimeUnit&nbsp;unit,
                                             <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
 replays all items emitted by that Observable within a specified time window. A Connectable Observable
 resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
 but only when its <code>connect()</code> method is called. 
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.ts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the duration of the window in which the replayed items must have been emitted<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler that is the time source for the window
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable and
         replays the items that were emitted during the window defined by <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211811.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="replay(rx.Scheduler)"><!-- --></A><H3>
replay</H3>
<PRE>
public final <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables">ConnectableObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>replay</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable that
 will replay all of its items and notifications to any future <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> on the given
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>. A Connectable Observable resembles an ordinary Observable, except that it does not
 begin emitting items when it is subscribed to, but only when its <code>connect()</code> method is called.
 <p>
 <img width="640" height="515" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the Scheduler on which the Observers will observe the emitted items
<DT><B>Returns:</B><DD>a <A HREF="../rx/observables/ConnectableObservable.html" title="class in rx.observables"><CODE>ConnectableObservable</CODE></A> that shares a single subscription to the source Observable that
         will replay all of its items and notifications to any future <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> on the given
         <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay">RxJava Wiki: replay()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211699.aspx">MSDN: Observable.Replay</a></DL>
</DD>
</DL>
<HR>

<A NAME="retry()"><!-- --></A><H3>
retry</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>retry</B>()</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 (infinite retry count).
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png">
 <p>
 If the source Observable calls <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>Observer.onError(java.lang.Throwable)</CODE></A>, this method will resubscribe to the source
 Observable rather than propagating the <code>onError</code> call.
 <p>
 Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
 those emitted during failed subscriptions. For example, if an Observable fails at first but emits
 <code>[1, 2]</code> then succeeds the second time and emits <code>[1, 2, 3, 4, 5]</code> then the complete sequence
 of emissions and notifications would be <code>[1, 2, 1, 2, 3, 4, 5, onCompleted]</code>.
 <p>
 <code>retry</code> operates by default on the <code>trampoline</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the source Observable modified with retry logic<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retry">RxJava Wiki: retry()</a></DL>
</DD>
</DL>
<HR>

<A NAME="retry(int)"><!-- --></A><H3>
retry</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>retry</B>(int&nbsp;retryCount)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 up to a specified number of retries.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png">
 <p>
 If the source Observable calls <A HREF="../rx/Observer.html#onError(java.lang.Throwable)"><CODE>Observer.onError(java.lang.Throwable)</CODE></A>, this method will resubscribe to the source
 Observable for a maximum of <code>retryCount</code> resubscriptions rather than propagating the
 <code>onError</code> call.
 <p>
 Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
 those emitted during failed subscriptions. For example, if an Observable fails at first but emits
 <code>[1, 2]</code> then succeeds the second time and emits <code>[1, 2, 3, 4, 5]</code> then the complete sequence
 of emissions and notifications would be <code>[1, 2, 1, 2, 3, 4, 5, onCompleted]</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>retryCount</CODE> - number of retry attempts before failing
<DT><B>Returns:</B><DD>the source Observable modified with retry logic<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retry">RxJava Wiki: retry()</a></DL>
</DD>
</DL>
<HR>

<A NAME="retry(rx.functions.Func2)"><!-- --></A><H3>
retry</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>retry</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;java.lang.Integer,java.lang.Throwable,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, resubscribing to it if it calls <code>onError</code>
 and the predicate returns true for that specific exception and retry count.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png">
 <p>
 <code>retry</code> operates by default on the <code>trampoline</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the predicate that determines if a resubscription may happen in case of a specific exception
            and retry count
<DT><B>Returns:</B><DD>the source Observable modified with retry logic<DT><B>See Also:</B><DD><A HREF="../rx/Observable.html#retry()"><CODE>Observable.retry()</CODE></A>, 
<a href="https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retry">RxJava Wiki: retry()</a></DL>
</DD>
</DL>
<HR>

<A NAME="sample(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
sample</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>sample</B>(long&nbsp;period,
                                  java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sample.png">
 <p>
 <code>sample</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>period</CODE> - the sampling rate<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> in which <code>period</code> is defined
<DT><B>Returns:</B><DD>an Observable that emits the results of sampling the items emitted by the source Observable at
         the specified time interval<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#sample-or-throttlelast">RxJava Wiki: sample()</a></DL>
</DD>
</DL>
<HR>

<A NAME="sample(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
sample</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>sample</B>(long&nbsp;period,
                                  java.util.concurrent.TimeUnit&nbsp;unit,
                                  <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
 within periodic time intervals, where the intervals are defined on a particular Scheduler.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sample.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>period</CODE> - the sampling rate<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> in which <code>period</code> is defined<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when sampling
<DT><B>Returns:</B><DD>an Observable that emits the results of sampling the items emitted by the source Observable at
         the specified time interval<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#sample-or-throttlelast">RxJava Wiki: sample()</a></DL>
</DD>
</DL>
<HR>

<A NAME="sample(rx.Observable)"><!-- --></A><H3>
sample</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>sample</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;sampler)</PRE>
<DL>
<DD>Returns an Observable that, when the specified <code>sampler</code> Observable emits an item or completes,
 emits the most recently emitted item (if any) emitted by the source Observable since the previous
 emission from the <code>sampler</code> Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sample.o.png">
 <p>
 This version of <code>sample</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sampler</CODE> - the Observable to use for sampling the source Observable
<DT><B>Returns:</B><DD>an Observable that emits the results of sampling the items emitted by this Observable whenever
         the <code>sampler</code> Observable emits an item or completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#sample-or-throttlelast">RxJava Wiki: sample()</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>scan</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable, then feeds the result of that function along with the second item emitted by the source
 Observable into the same function, and so on until all items have been emitted by the source Observable,
 emitting the result of each of these iterations.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scan.png">
 <p>
 This sort of function is sometimes called an accumulator.
 <p>
 <code>scan</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - an accumulator function to be invoked on each item emitted by the source Observable, whose
            result will be emitted to <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s via <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> and used in the
            next accumulator call
<DT><B>Returns:</B><DD>an Observable that emits the results of each call to the accumulator function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#scan">RxJava Wiki: scan()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211665.aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(java.lang.Object,rx.functions.Func2)"><!-- --></A><A NAME="scan(R, rx.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>scan</B>(R&nbsp;initialValue,
                                    <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;R,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns an Observable that applies a function of your choosing to the first item emitted by a source
 Observable and a seed value, then feeds the result of that function along with the second item emitted by
 the source Observable into the same function, and so on until all items have been emitted by the source
 Observable, emitting the result of each of these iterations.
 <p>
 <img width="640" height="320" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scanSeed.png">
 <p>
 This sort of function is sometimes called an accumulator.
 <p>
 Note that the Observable that results from this method will emit <code>initialValue</code> as its first
 emitted item.
 <p>
 <code>scan</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - the initial (seed) accumulator item<DD><CODE>accumulator</CODE> - an accumulator function to be invoked on each item emitted by the source Observable, whose
            result will be emitted to <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s via <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> and used in the
            next accumulator call
<DT><B>Returns:</B><DD>an Observable that emits <code>initialValue</code> followed by the results of each call to the
         accumulator function<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#scan">RxJava Wiki: scan()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211665.aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="serialize()"><!-- --></A><H3>
serialize</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>serialize</B>()</PRE>
<DL>
<DD>Forces an Observable's emissions and notifications to be serialized and for it to obey the Rx contract
 in other ways.
 <p>
 It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps from
 different threads. This could make such an Observable poorly-behaved, in that it might try to invoke
 <code>onCompleted</code> or <code>onError</code> before one of its <code>onNext</code> invocations, or it might call
 <code>onNext</code> from two different threads concurrently. You can force such an Observable to be
 well-behaved and sequential by applying the <code>serialize</code> method to it.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png">
 <p>
 <code>serialize</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> that is guaranteed to be well-behaved and to make only serialized calls to
         its observers<DT><B>Since:</B></DT>
  <DD>0.17</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize">RxJava Wiki: serialize()</a></DL>
</DD>
</DL>
<HR>

<A NAME="share()"><!-- --></A><H3>
share</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>share</B>()</PRE>
<DL>
<DD>Returns a new <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> that multicasts (shares) the original <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A>. As long as
 there is more than 1 <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> this <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> will be subscribed and emitting data. 
 When all subscribers have unsubscribed it will unsubscribe from the source <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A>. 
 <p>
 This is an alias for <A HREF="../rx/Observable.html#publish()"><CODE>Observable.publish()</CODE></A>.<A HREF="../rx/observables/ConnectableObservable.html#refCount()"><CODE>ConnectableObservable.refCount()</CODE></A>.
 <p>
 <img width="640" height="510" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png">
 <p>
 <code>share</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> that upon connection causes the source Observable to emit items
         to its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount">RxJava Wiki: refCount()</a></DL>
</DD>
</DL>
<HR>

<A NAME="single()"><!-- --></A><H3>
single</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>single</B>()</PRE>
<DL>
<DD>Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item. If the source Observable emits more than one item or no items, notify of an
 <code>IllegalArgumentException</code> or <code>NoSuchElementException</code> respectively.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/single.png">
 <p>
 <code>single</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits the single item emitted by the source Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the source emits more than one item
<DD><CODE>java.util.NoSuchElementException</CODE> - if the source emits no items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#single-and-singleordefault">RxJava Wiki: single()</a>, 
"MSDN: Observable.singleAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="single(rx.functions.Func1)"><!-- --></A><H3>
single</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>single</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits the single item emitted by the source Observable that matches a
 specified predicate, if that Observable emits one such item. If the source Observable emits more than one
 such item or no such items, notify of an <code>IllegalArgumentException</code> or
 <code>NoSuchElementException</code> respectively.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/single.p.png">
 <p>
 <code>single</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a predicate function to evaluate items emitted by the source Observable
<DT><B>Returns:</B><DD>an Observable that emits the single item emitted by the source Observable that matches the
         predicate
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the source Observable emits more than one item that matches the predicate
<DD><CODE>java.util.NoSuchElementException</CODE> - if the source Observable emits no item that matches the predicate<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#single-and-singleordefault">RxJava Wiki: single()</a>, 
"MSDN: Observable.singleAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="singleOrDefault(java.lang.Object)"><!-- --></A><A NAME="singleOrDefault(T)"><!-- --></A><H3>
singleOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>singleOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue)</PRE>
<DL>
<DD>Returns an Observable that emits the single item emitted by the source Observable, if that Observable
 emits only a single item, or a default item if the source Observable emits no items. If the source
 Observable emits more than one item, throw an <code>IllegalArgumentException</code>.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/singleOrDefault.png">
 <p>
 <code>singleOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - a default value to emit if the source Observable emits no item
<DT><B>Returns:</B><DD>an Observable that emits the single item emitted by the source Observable, or a default item if
         the source Observable is empty
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the source Observable emits more than one item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#single-and-singleordefault">RxJava Wiki: single()</a>, 
"MSDN: Observable.singleOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="singleOrDefault(java.lang.Object,rx.functions.Func1)"><!-- --></A><A NAME="singleOrDefault(T, rx.functions.Func1)"><!-- --></A><H3>
singleOrDefault</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>singleOrDefault</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;defaultValue,
                                           <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits the single item emitted by the source Observable that matches a
 predicate, if that Observable emits only one such item, or a default item if the source Observable emits
 no such items. If the source Observable emits more than one such item, throw an
 <code>IllegalArgumentException</code>.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/singleOrDefault.p.png">
 <p>
 <code>singleOrDefault</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>defaultValue</CODE> - a default item to emit if the source Observable emits no matching items<DD><CODE>predicate</CODE> - a predicate function to evaluate items emitted by the source Observable
<DT><B>Returns:</B><DD>an Observable that emits the single item emitted by the source Observable that matches the
         predicate, or the default item if no emitted item matches the predicate
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the source Observable emits more than one item that matches the predicate<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#single-and-singleordefault">RxJava Wiki: single()</a>, 
"MSDN: Observable.singleOrDefaultAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="skip(int)"><!-- --></A><H3>
skip</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skip</B>(int&nbsp;num)</PRE>
<DL>
<DD>Returns an Observable that skips the first <code>num</code> items emitted by the source Observable and emits
 the remainder.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.png">
 <p>
 This version of <code>skip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>num</CODE> - the number of items to skip
<DT><B>Returns:</B><DD>an Observable that is identical to the source Observable except that it does not emit the first
         <code>num</code> items that the source Observable emits<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skip">RxJava Wiki: skip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="skip(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
skip</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skip</B>(long&nbsp;time,
                                java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that skips values emitted by the source Observable before a specified time window
 elapses.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.t.png">
 <p>
 This version of <code>skip</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window to skip<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that skips values emitted by the source Observable before the time window defined
         by <code>time</code> elapses and the emits the remainder<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skip">RxJava Wiki: skip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="skip(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
skip</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skip</B>(long&nbsp;time,
                                java.util.concurrent.TimeUnit&nbsp;unit,
                                <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that skips values emitted by the source Observable before a specified time window
 on a specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> elapses.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.ts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window to skip<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> on which the timed wait happens
<DT><B>Returns:</B><DD>an Observable that skips values emitted by the source Observable before the time window defined
         by <code>time</code> and <code>scheduler</code> elapses, and then emits the remainder<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skip">RxJava Wiki: skip()</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipLast(int)"><!-- --></A><H3>
skipLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipLast</B>(int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
 source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.png">
 <p>
 This Observer accumulates a queue long enough to store the first <code>count</code> items. As more items are
 received, items are taken from the front of the queue and emitted by the returned Observable. This causes
 such items to be delayed.
 <p>
 This version of <code>skipLast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - number of items to drop from the end of the source sequence
<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the source Observable except for the dropped ones
         at the end
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>count</code> is less than zero<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skiplast">RxJava Wiki: skipLast()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211750.aspx">MSDN: Observable.SkipLast</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipLast(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
skipLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipLast</B>(long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that drops items emitted by the source Observable during a specified time window
 before the source completes.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.t.png">
 <p>
 Note: this action will cache the latest items arriving in the specified time window.
 <p>
 This version of <code>skipLast</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that drops those items emitted by the source Observable in a time window before the
         source completes defined by <code>time</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skiplast">RxJava Wiki: skipLast()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211750.aspx">MSDN: Observable.SkipLast</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
skipLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipLast</B>(long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit,
                                    <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that drops items emitted by the source Observable during a specified time window
 (defined on a specified scheduler) before the source completes.
 <p>
 <img width="640" height="340" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.ts.png">
 <p>
 Note: this action will cache the latest items arriving in the specified time window.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the scheduler used as the time source
<DT><B>Returns:</B><DD>an Observable that drops those items emitted by the source Observable in a time window before the
         source completes defined by <code>time</code> and <code>scheduler</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skiplast">RxJava Wiki: skipLast()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211750.aspx">MSDN: Observable.SkipLast</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipUntil(rx.Observable)"><!-- --></A><H3>
skipUntil</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipUntil</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;other)</PRE>
<DL>
<DD>Returns an Observable that skips items emitted by the source Observable until a second Observable emits
 an item.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipUntil.png">
 <p>
 <code>skipUntil</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - the second Observable that has to emit an item before the source Observable's elements begin
            to be mirrored by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that skips items from the source Observable until the second Observable emits an
         item, then emits the remaining items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#skipuntil">RxJava Wiki: skipUntil()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229358.aspx">MSDN: Observable.SkipUntil</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipWhile(rx.functions.Func1)"><!-- --></A><H3>
skipWhile</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipWhile</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that skips all items emitted by the source Observable as long as a specified
 condition holds true, but emits all further source items as soon as the condition becomes false.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipWhile.png">
 <p>
 <code>skipWhile</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function to test each item emitted from the source Observable
<DT><B>Returns:</B><DD>an Observable that begins emitting items emitted by the source Observable when the specified
         predicate becomes false<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#skipwhile-and-skipwhilewithindex">RxJava Wiki: skipWhile()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229685.aspx">MSDN: Observable.SkipWhile</a></DL>
</DD>
</DL>
<HR>

<A NAME="skipWhileWithIndex(rx.functions.Func2)"><!-- --></A><H3>
skipWhileWithIndex</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skipWhileWithIndex</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that skips all items emitted by the source Observable as long as a specified
 condition holds true, but emits all further source items as soon as the condition becomes false.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipWhileWithIndex.png">
 <p>
 <code>skipWhileWithIndex</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function to test each item emitted from the source Observable. It takes the emitted item as
            the first parameter and the sequential index of the emitted item as a second parameter.
<DT><B>Returns:</B><DD>an Observable that begins emitting items emitted by the source Observable when the specified
         predicate becomes false<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#skipwhile-and-skipwhilewithindex">RxJava Wiki: skipWhileWithIndex()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211631.aspx">MSDN: Observable.SkipWhile</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(rx.Observable)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values)</PRE>
<DL>
<DD>Returns an Observable that emits the items in a specified <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> before it begins to emit
 items emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.o.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>values</CODE> - an Observable that contains the items you want the modified Observable to emit first
<DT><B>Returns:</B><DD>an Observable that emits the items in the specified <A HREF="../rx/Observable.html" title="class in rx"><CODE>Observable</CODE></A> and then emits the items
         emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Iterable)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(java.lang.Iterable&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values)</PRE>
<DL>
<DD>Returns an Observable that emits the items in a specified <CODE>Iterable</CODE> before it begins to emit items
 emitted by the source Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>values</CODE> - an Iterable that contains the items you want the modified Observable to emit first
<DT><B>Returns:</B><DD>an Observable that emits the items in the specified <CODE>Iterable</CODE> and then emits the items
         emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Iterable, rx.Scheduler)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(java.lang.Iterable&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;values,
                                     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits the items in a specified <CODE>Iterable</CODE>, on a specified
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>, before it begins to emit items emitted by the source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>values</CODE> - an Iterable that contains the items you want the modified Observable to emit first<DD><CODE>scheduler</CODE> - the Scheduler to emit the prepended values on
<DT><B>Returns:</B><DD>an Observable that emits the items in the specified <CODE>Iterable</CODE> and then emits the items
         emitted by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229372.aspx">MSDN: Observable.StartWith</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object)"><!-- --></A><A NAME="startWith(T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1)</PRE>
<DL>
<DD>Returns an Observable that emits a specified item before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified item before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit<DD><CODE>t5</CODE> - the fifth item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit<DD><CODE>t5</CODE> - the fifth item to emit<DD><CODE>t6</CODE> - the sixth item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted
         by the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit<DD><CODE>t5</CODE> - the fifth item to emit<DD><CODE>t6</CODE> - the sixth item to emit<DD><CODE>t7</CODE> - the seventh item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T, T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t8)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit<DD><CODE>t5</CODE> - the fifth item to emit<DD><CODE>t6</CODE> - the sixth item to emit<DD><CODE>t7</CODE> - the seventh item to emit<DD><CODE>t8</CODE> - the eighth item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="startWith(T, T, T, T, T, T, T, T, T)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t1,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t2,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t3,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t4,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t5,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t6,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t7,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t8,
                                     <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;t9)</PRE>
<DL>
<DD>Returns an Observable that emits the specified items before it begins to emit items emitted by the source
 Observable.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png">
 <p>
 <code>startWith</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t1</CODE> - the first item to emit<DD><CODE>t2</CODE> - the second item to emit<DD><CODE>t3</CODE> - the third item to emit<DD><CODE>t4</CODE> - the fourth item to emit<DD><CODE>t5</CODE> - the fifth item to emit<DD><CODE>t6</CODE> - the sixth item to emit<DD><CODE>t7</CODE> - the seventh item to emit<DD><CODE>t8</CODE> - the eighth item to emit<DD><CODE>t9</CODE> - the ninth item to emit
<DT><B>Returns:</B><DD>an Observable that emits the specified items before it begins to emit items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a></DL>
</DD>
</DL>
<HR>

<A NAME="startWith(java.lang.Object[],rx.Scheduler)"><!-- --></A><A NAME="startWith(T[], rx.Scheduler)"><!-- --></A><H3>
startWith</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>startWith</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>[]&nbsp;values,
                                     <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits the items from a specified array, on a specified Scheduler, before it
 begins to emit items emitted by the source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>values</CODE> - the items you want the modified Observable to emit first<DD><CODE>scheduler</CODE> - the Scheduler to emit the prepended values on
<DT><B>Returns:</B><DD>an Observable that emits the items from <code>values</code>, on <code>scheduler</code>, before it begins to
         emit items emitted by the source Observable.<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#startwith">RxJava Wiki: startWith()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229372.aspx">MSDN: Observable.StartWith</a></DL>
</DD>
</DL>
<HR>

<A NAME="subscribe()"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>()</PRE>
<DL>
<DD>Subscribes to an Observable but ignore its emissions and notifications.
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> can stop receiving items before
         the Observable has finished sending them
<DT><B>Throws:</B>
<DD><CODE><A HREF="../rx/exceptions/OnErrorNotImplementedException.html" title="class in rx.exceptions">OnErrorNotImplementedException</A></CODE> - if the Observable tries to call <code>onError</code></DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.functions.Action1)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</PRE>
<DL>
<DD>Subscribes to an Observable and provides a callback to handle the items it emits.
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - the <code>Action1&lt;T&gt;</code> you have designed to accept emissions from the Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> can stop receiving items before
         the Observable has finished sending them
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null
<DD><CODE><A HREF="../rx/exceptions/OnErrorNotImplementedException.html" title="class in rx.exceptions">OnErrorNotImplementedException</A></CODE> - if the Observable tries to call <code>onError</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.functions.Action1, rx.functions.Action1)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                                    <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError)</PRE>
<DL>
<DD>Subscribes to an Observable and provides callbacks to handle the items it emits and any error
 notification it issues.
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - the <code>Action1&lt;T&gt;</code> you have designed to accept emissions from the Observable<DD><CODE>onError</CODE> - the <code>Action1&lt;Throwable&gt;</code> you have designed to accept any error notification from the
             Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> can stop receiving items before
         the Observable has finished sending them
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null, or
             if <code>onError</code> is null<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                                    <A HREF="../rx/functions/Action1.html" title="interface in rx.functions">Action1</A>&lt;java.lang.Throwable&gt;&nbsp;onError,
                                    <A HREF="../rx/functions/Action0.html" title="interface in rx.functions">Action0</A>&nbsp;onComplete)</PRE>
<DL>
<DD>Subscribes to an Observable and provides callbacks to handle the items it emits and any error or
 completion notification it issues.
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>onNext</CODE> - the <code>Action1&lt;T&gt;</code> you have designed to accept emissions from the Observable<DD><CODE>onError</CODE> - the <code>Action1&lt;Throwable&gt;</code> you have designed to accept any error notification from the
             Observable<DD><CODE>onComplete</CODE> - the <code>Action0</code> you have designed to accept a completion notification from the
             Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> can stop receiving items before
         the Observable has finished sending them
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>onNext</code> is null, or
             if <code>onError</code> is null, or
             if <code>onComplete</code> is null<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.Observer)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</PRE>
<DL>
<DD>Subscribes to an Observable and provides an Observer that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>observer</CODE> - the Observer that will handle emissions and notifications from the Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A> can stop receiving items before
         the Observable has completed<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable#onnext-oncompleted-and-onerror">RxJava Wiki: onNext, onCompleted, and onError</a></DL>
</DD>
</DL>
<HR>

<A NAME="unsafeSubscribe(rx.Subscriber)"><!-- --></A><H3>
unsafeSubscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>unsafeSubscribe</B>(<A HREF="../rx/Subscriber.html" title="class in rx">Subscriber</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;subscriber)</PRE>
<DL>
<DD>Subscribes to an Observable and invokes <A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><CODE>Observable.OnSubscribe</CODE></A> function without any contract protection,
 error handling, unsubscribe, or execution hooks.
 <p>
 Use this only for implementing an <A HREF="../rx/Observable.Operator.html" title="interface in rx"><CODE>Observable.Operator</CODE></A> that requires nested subscriptions. For other
 purposes, use <A HREF="../rx/Observable.html#subscribe(rx.Subscriber)"><CODE>Observable.subscribe(Subscriber)</CODE></A> which ensures the Rx contract and other functionality.
 <p>
 <code>unsafeSubscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>subscriber</CODE> - the Subscriber that will handle emissions and notifications from the Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> can stop receiving items
         before the Observable has completed<DT><B>Since:</B></DT>
  <DD>0.17</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.Subscriber)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public final <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/Subscriber.html" title="class in rx">Subscriber</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;subscriber)</PRE>
<DL>
<DD>Subscribes to an Observable and provides a Subscriber that implements functions to handle the items the
 Observable emits and any error or completion notification it issues.
 <p>
 A typical implementation of <code>subscribe</code> does the following:
 <ol>
 <li>It stores a reference to the Subscriber in a collection object, such as a <code>List&lt;T&gt;</code> object.</li>
 <li>It returns a reference to the <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> interface. This enables Subscribers to
 unsubscribe, that is, to stop receiving items and notifications before the Observable completes, which
 also invokes the Subscriber's <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A> method.</li>
 </ol><p>
 An <code>Observable&lt;T&gt;</code> instance is responsible for accepting all subscriptions and notifying all
 Subscribers. Unless the documentation for a particular <code>Observable&lt;T&gt;</code> implementation indicates
 otherwise, Subscriber should make no assumptions about the order in which multiple Subscribers will
 receive their notifications.
 <p>
 For more information see the
 <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>
 <p>
 <code>subscribe</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>subscriber</CODE> - the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> that will handle emissions and notifications from the Observable
<DT><B>Returns:</B><DD>a <A HREF="../rx/Subscription.html" title="interface in rx"><CODE>Subscription</CODE></A> reference with which Subscribers that are <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>s can
         unsubscribe from the Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>subscribe</code> is unable to obtain an <code>OnSubscribe&lt;&gt;</code> function
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A> provided as the argument to <code>subscribe</code> is <code>null</code>
<DD><CODE><A HREF="../rx/exceptions/OnErrorNotImplementedException.html" title="class in rx.exceptions">OnErrorNotImplementedException</A></CODE> - if the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A>'s <code>onError</code> method is null
<DD><CODE>java.lang.RuntimeException</CODE> - if the <A HREF="../rx/Subscriber.html" title="class in rx"><CODE>Subscriber</CODE></A>'s <code>onError</code> method itself threw a <code>Throwable</code></DL>
</DD>
</DL>
<HR>

<A NAME="subscribeOn(rx.Scheduler)"><!-- --></A><H3>
subscribeOn</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>subscribeOn</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Asynchronously subscribes Observers to this Observable on the specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/subscribeOn.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to perform subscription actions on
<DT><B>Returns:</B><DD>the source Observable modified so that its subscriptions happen on the
         specified <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#subscribeon">RxJava Wiki: subscribeOn()</a>, 
<a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>, 
<A HREF="../rx/Observable.html#observeOn(rx.Scheduler)"><CODE>Observable.observeOn(rx.Scheduler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="switchMap(rx.functions.Func1)"><!-- --></A><H3>
switchMap</H3>
<PRE>
public final &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>switchMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Returns a new Observable by applying a function that you supply to each item emitted by the source
 Observable that returns an Observable, and then emitting the items emitted by the most recently emitted
 of these Observables.
 <p>
 <img width="640" height="350" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/switchMap.png">
 <p>
 <code>switchMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a function that, when applied to an item emitted by the source Observable, returns an
            Observable
<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the Observable returned from applying <code>func</code> to the most recently emitted item emitted by the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="take(int)"><!-- --></A><H3>
take</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>take</B>(int&nbsp;num)</PRE>
<DL>
<DD>Returns an Observable that emits only the first <code>num</code> items emitted by the source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.png">
 <p>
 This method returns an Observable that will invoke a subscribing <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s
 <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> function a maximum of <code>num</code> times before invoking
 <A HREF="../rx/Observer.html#onCompleted()"><CODE>onCompleted</CODE></A>.
 <p>
 This version of <code>take</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>num</CODE> - the maximum number of items to emit
<DT><B>Returns:</B><DD>an Observable that emits only the first <code>num</code> items emitted by the source Observable, or
         all of the items from the source Observable if that Observable emits fewer than <code>num</code> items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#take">RxJava Wiki: take()</a></DL>
</DD>
</DL>
<HR>

<A NAME="take(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
take</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>take</B>(long&nbsp;time,
                                java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits those items emitted by source Observable before a specified time runs
 out.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.t.png">
 <p>
 This version of <code>take</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits those items emitted by the source Observable before the time runs out<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#take">RxJava Wiki: take()</a></DL>
</DD>
</DL>
<HR>

<A NAME="take(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
take</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>take</B>(long&nbsp;time,
                                java.util.concurrent.TimeUnit&nbsp;unit,
                                <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits those items emitted by source Observable before a specified time (on a
 specified Scheduler) runs out.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.ts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler used for time source
<DT><B>Returns:</B><DD>an Observable that emits those items emitted by the source Observable before the time runs out,
         according to the specified Scheduler<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#take">RxJava Wiki: take()</a></DL>
</DD>
</DL>
<HR>

<A NAME="takeFirst(rx.functions.Func1)"><!-- --></A><H3>
takeFirst</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeFirst</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
 a specified condition.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeFirstN.png">
 <p>
 <code>takeFirst</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - the condition any item emitted by the source Observable has to satisfy
<DT><B>Returns:</B><DD>an Observable that emits only the very first item emitted by the source Observable that satisfies
         the given condition, or that completes without emitting anything if the source Observable
         completes without emitting a single condition-satisfying item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#first">RxJava Wiki: first()</a>, 
"MSDN: Observable.firstAsync()"</DL>
</DD>
</DL>
<HR>

<A NAME="takeLast(int)"><!-- --></A><H3>
takeLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeLast</B>(int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits only the last <code>count</code> items emitted by the source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLast.n.png">
 <p>
 This version of <code>takeLast</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the number of items to emit from the end of the sequence of items emitted by the source
            Observable
<DT><B>Returns:</B><DD>an Observable that emits only the last <code>count</code> items emitted by the source Observable
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>count</code> is less than zero<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#takelast">RxJava Wiki: takeLast()</a></DL>
</DD>
</DL>
<HR>

<A NAME="takeLast(int, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
takeLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeLast</B>(int&nbsp;count,
                                    long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLast.tn.png">
 <p>
 This version of <code>takeLast</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum number of items to emit<DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits at most <code>count</code> items from the source Observable that were emitted
         in a specified window of time before the Observable completed</DL>
</DD>
</DL>
<HR>

<A NAME="takeLast(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
takeLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeLast</B>(int&nbsp;count,
                                    long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit,
                                    <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits at most a specified number of items from the source Observable that were
 emitted in a specified window of time before the Observable completed, where the timing information is
 provided by a given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLast.tns.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum number of items to emit<DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> that provides the timestamps for the observed items
<DT><B>Returns:</B><DD>an Observable that emits at most <code>count</code> items from the source Observable that were emitted
         in a specified window of time before the Observable completed, where the timing information is
         provided by the given <code>scheduler</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>count</code> is less than zero</DL>
</DD>
</DL>
<HR>

<A NAME="takeLast(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
takeLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeLast</B>(long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLast.t.png">
 <p>
 This version of <code>takeLast</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits the items from the source Observable that were emitted in the window of
         time before the Observable completed specified by <code>time</code></DL>
</DD>
</DL>
<HR>

<A NAME="takeLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
takeLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeLast</B>(long&nbsp;time,
                                    java.util.concurrent.TimeUnit&nbsp;unit,
                                    <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits the items from the source Observable that were emitted in a specified
 window of time before the Observable completed, where the timing information is provided by a specified
 Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLast.ts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler that provides the timestamps for the Observed items
<DT><B>Returns:</B><DD>an Observable that emits the items from the source Observable that were emitted in the window of
         time before the Observable completed specified by <code>time</code>, where the timing information is
         provided by <code>scheduler</code></DL>
</DD>
</DL>
<HR>

<A NAME="takeLastBuffer(int)"><!-- --></A><H3>
takeLastBuffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>takeLastBuffer</B>(int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits a single List containing the last <code>count</code> elements emitted by the
 source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLastBuffer.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the number of items to emit in the list
<DT><B>Returns:</B><DD>an Observable that emits a single list containing the last <code>count</code> elements emitted by the
         source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="takeLastBuffer(int, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
takeLastBuffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>takeLastBuffer</B>(int&nbsp;count,
                                                          long&nbsp;time,
                                                          java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time before the source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLastBuffer.tn.png">
 <p>
 This version of <code>takeLastBuffer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum number of items to emit<DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits a single List containing at most <code>count</code> items emitted by the
         source Observable during the time window defined by <code>time</code> before the source Observable
         completed</DL>
</DD>
</DL>
<HR>

<A NAME="takeLastBuffer(int, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
takeLastBuffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>takeLastBuffer</B>(int&nbsp;count,
                                                          long&nbsp;time,
                                                          java.util.concurrent.TimeUnit&nbsp;unit,
                                                          <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a single List containing at most <code>count</code> items from the source
 Observable that were emitted during a specified window of time (on a specified Scheduler) before the
 source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLastBuffer.tns.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum number of items to emit<DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler that provides the timestamps for the observed items
<DT><B>Returns:</B><DD>an Observable that emits a single List containing at most <code>count</code> items emitted by the
         source Observable during the time window defined by <code>time</code> before the source Observable
         completed</DL>
</DD>
</DL>
<HR>

<A NAME="takeLastBuffer(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
takeLastBuffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>takeLastBuffer</B>(long&nbsp;time,
                                                          java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLastBuffer.t.png">
 <p>
 This version of <code>takeLastBuffer</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code>
<DT><B>Returns:</B><DD>an Observable that emits a single List containing the items emitted by the source Observable
         during the time window defined by <code>time</code> before the source Observable completed</DL>
</DD>
</DL>
<HR>

<A NAME="takeLastBuffer(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
takeLastBuffer</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>takeLastBuffer</B>(long&nbsp;time,
                                                          java.util.concurrent.TimeUnit&nbsp;unit,
                                                          <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits a single List containing those items from the source Observable that
 were emitted during a specified window of time before the source Observable completed, where the timing
 information is provided by the given Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeLastBuffer.ts.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the length of the time window<DD><CODE>unit</CODE> - the time unit of <code>time</code><DD><CODE>scheduler</CODE> - the Scheduler that provides the timestamps for the observed items
<DT><B>Returns:</B><DD>an Observable that emits a single List containing the items emitted by the source Observable
         during the time window defined by <code>time</code> before the source Observable completed, where the
         timing information is provided by <code>scheduler</code></DL>
</DD>
</DL>
<HR>

<A NAME="takeUntil(rx.Observable)"><!-- --></A><H3>
takeUntil</H3>
<PRE>
public final &lt;E&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeUntil</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends E&gt;&nbsp;other)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by the source Observable until a second Observable
 emits an item.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeUntil.png">
 <p>
 <code>takeUntil</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>E</CODE> - the type of items emitted by <code>other</code><DT><B>Parameters:</B><DD><CODE>other</CODE> - the Observable whose first emitted item will cause <code>takeUntil</code> to stop emitting items
            from the source Observable
<DT><B>Returns:</B><DD>an Observable that emits the items emitted by the source Observable until such time as <code>other</code> emits its first item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#takeuntil">RxJava Wiki: takeUntil()</a></DL>
</DD>
</DL>
<HR>

<A NAME="takeWhile(rx.functions.Func1)"><!-- --></A><H3>
takeWhile</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeWhile</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits items emitted by the source Observable so long as each item satisfied a
 specified condition, and then completes as soon as this condition is not satisfied.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeWhile.png">
 <p>
 <code>takeWhile</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function that evaluates an item emitted by the source Observable and returns a Boolean
<DT><B>Returns:</B><DD>an Observable that emits the items from the source Observable so long as each item satisfies the
         condition defined by <code>predicate</code>, then completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#takewhile-and-takewhilewithindex">RxJava Wiki: takeWhile()</a></DL>
</DD>
</DL>
<HR>

<A NAME="takeWhileWithIndex(rx.functions.Func2)"><!-- --></A><H3>
takeWhileWithIndex</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>takeWhileWithIndex</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super java.lang.Integer,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Returns an Observable that emits the items emitted by a source Observable so long as a given predicate
 remains true, where the predicate operates on both the item and its index relative to the complete
 sequence of emitted items.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/takeWhileWithIndex.png">
 <p>
 <code>takeWhile</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a function to test each item emitted by the source Observable for a condition; the second
            parameter of the function represents the sequential index of the source item; it returns a
            Boolean
<DT><B>Returns:</B><DD>an Observable that emits items from the source Observable so long as the predicate continues to
         return <code>true</code> for each item, then completes<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Conditional-and-Boolean-Operators#takewhile-and-takewhilewithindex">RxJava Wiki: takeWhileWithIndex()</a></DL>
</DD>
</DL>
<HR>

<A NAME="throttleFirst(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
throttleFirst</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleFirst</B>(long&nbsp;windowDuration,
                                         java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration.
 <p>
 This differs from <A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleLast(long, java.util.concurrent.TimeUnit)</CODE></A> in that this only tracks passage of time whereas
 <A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleLast(long, java.util.concurrent.TimeUnit)</CODE></A> ticks at scheduled intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleFirst.png">
 <p>
 <code>throttleFirst</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>windowDuration</CODE> - time to wait before emitting another item after emitting the last item<DD><CODE>unit</CODE> - the unit of time of <code>windowDuration</code>
<DT><B>Returns:</B><DD>an Observable that performs the throttle operation<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlefirst">RxJava Wiki: throttleFirst()</a></DL>
</DD>
</DL>
<HR>

<A NAME="throttleFirst(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
throttleFirst</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleFirst</B>(long&nbsp;skipDuration,
                                         java.util.concurrent.TimeUnit&nbsp;unit,
                                         <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits only the first item emitted by the source Observable during sequential
 time windows of a specified duration, where the windows are managed by a specified Scheduler.
 <p>
 This differs from <A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleLast(long, java.util.concurrent.TimeUnit)</CODE></A> in that this only tracks passage of time whereas
 <A HREF="../rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleLast(long, java.util.concurrent.TimeUnit)</CODE></A> ticks at scheduled intervals.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleFirst.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>skipDuration</CODE> - time to wait before emitting another item after emitting the last item<DD><CODE>unit</CODE> - the unit of time of <code>skipDuration</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use internally to manage the timers that handle timeout for each
            event
<DT><B>Returns:</B><DD>an Observable that performs the throttle operation<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlefirst">RxJava Wiki: throttleFirst()</a></DL>
</DD>
</DL>
<HR>

<A NAME="throttleLast(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
throttleLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleLast</B>(long&nbsp;intervalDuration,
                                        java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration.
 <p>
 This differs from <A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleFirst(long, java.util.concurrent.TimeUnit)</CODE></A> in that this ticks along at a scheduled interval whereas
 <A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleFirst(long, java.util.concurrent.TimeUnit)</CODE></A> does not tick, it just tracks passage of time.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleLast.png">
 <p>
 <code>throttleLast</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>intervalDuration</CODE> - duration of windows within which the last item emitted by the source Observable will be
            emitted<DD><CODE>unit</CODE> - the unit of time of <code>intervalDuration</code>
<DT><B>Returns:</B><DD>an Observable that performs the throttle operation<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#takelast">RxJava Wiki: throttleLast()</a>, 
<A HREF="../rx/Observable.html#sample(long, java.util.concurrent.TimeUnit)"><CODE>Observable.sample(long, TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="throttleLast(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
throttleLast</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleLast</B>(long&nbsp;intervalDuration,
                                        java.util.concurrent.TimeUnit&nbsp;unit,
                                        <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits only the last item emitted by the source Observable during sequential
 time windows of a specified duration, where the duration is governed by a specified Scheduler.
 <p>
 This differs from <A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleFirst(long, java.util.concurrent.TimeUnit)</CODE></A> in that this ticks along at a scheduled interval whereas
 <A HREF="../rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit)"><CODE>Observable.throttleFirst(long, java.util.concurrent.TimeUnit)</CODE></A> does not tick, it just tracks passage of time.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleLast.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>intervalDuration</CODE> - duration of windows within which the last item emitted by the source Observable will be
            emitted<DD><CODE>unit</CODE> - the unit of time of <code>intervalDuration</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use internally to manage the timers that handle timeout for each
            event
<DT><B>Returns:</B><DD>an Observable that performs the throttle operation<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#takelast">RxJava Wiki: throttleLast()</a>, 
<A HREF="../rx/Observable.html#sample(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><CODE>Observable.sample(long, TimeUnit, Scheduler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="throttleWithTimeout(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
throttleWithTimeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleWithTimeout</B>(long&nbsp;timeout,
                                               java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window.
 <p>
 <em>Note:</em> If the source Observable keeps emitting items more frequently than the length of the time
 window then no items will be emitted by the resulting Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleWithTimeout.png">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
 <p>
 <code>throttleWithTimeout</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the length of the window of time that must pass after the emission of an item from the source
            Observable in which that Observable emits no items in order for the item to be emitted by the
            resulting Observable<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> of <code>timeout</code>
<DT><B>Returns:</B><DD>an Observable that filters out items that are too quickly followed by newer items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlewithtimeout-or-debounce">RxJava Wiki: throttleWithTimeout()</a>, 
<A HREF="../rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit)"><CODE>Observable.debounce(long, TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="throttleWithTimeout(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
throttleWithTimeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>throttleWithTimeout</B>(long&nbsp;timeout,
                                               java.util.concurrent.TimeUnit&nbsp;unit,
                                               <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that only emits those items emitted by the source Observable that are not followed
 by another emitted item within a specified time window, where the time window is governed by a specified
 Scheduler.
 <p>
 <em>Note:</em> If the source Observable keeps emitting items more frequently than the length of the time
 window then no items will be emitted by the resulting Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/throttleWithTimeout.s.png">
 <p>
 Information on debounce vs throttle:
 <p>
 <ul>
 <li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">Debounce and Throttle: visual explanation</a></li>
 <li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/">Debouncing: javascript methods</a></li>
 <li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/">Javascript - don't spam your server: debounce and throttle</a></li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - the length of the window of time that must pass after the emission of an item from the source
            Observable in which that Observable emits no items in order for the item to be emitted by the
            resulting Observable<DD><CODE>unit</CODE> - the <CODE>TimeUnit</CODE> of <code>timeout</code><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use internally to manage the timers that handle the timeout for each
            item
<DT><B>Returns:</B><DD>an Observable that filters out items that are too quickly followed by newer items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#throttlewithtimeout-or-debounce">RxJava Wiki: throttleWithTimeout()</a>, 
<A HREF="../rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><CODE>Observable.debounce(long, TimeUnit, Scheduler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="timeInterval()"><!-- --></A><H3>
timeInterval</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/TimeInterval.html" title="class in rx.schedulers">TimeInterval</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>timeInterval</B>()</PRE>
<DL>
<DD>Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeInterval.png">
 <p>
 <code>timeInterval</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits time interval information items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#timeinterval">RxJava Wiki: timeInterval()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212107.aspx">MSDN: Observable.TimeInterval</a></DL>
</DD>
</DL>
<HR>

<A NAME="timeInterval(rx.Scheduler)"><!-- --></A><H3>
timeInterval</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/TimeInterval.html" title="class in rx.schedulers">TimeInterval</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>timeInterval</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits records of the time interval between consecutive items emitted by the
 source Observable, where this interval is computed on a specified Scheduler.
 <p>
 <img width="640" height="315" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeInterval.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> used to compute time intervals
<DT><B>Returns:</B><DD>an Observable that emits time interval information items<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#timeinterval">RxJava Wiki: timeInterval()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212107.aspx">MSDN: Observable.TimeInterval</a></DL>
</DD>
</DL>
<HR>

<A NAME="timeout(rx.functions.Func0, rx.functions.Func1)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final &lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;firstTimeoutSelector,
                                         <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
 either the first item emitted by the source Observable or any subsequent item don't arrive within time
 windows defined by other Observables.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout5.png">
 <p>
 This version of <code>timeout</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the first timeout value type (ignored)<DD><CODE>V</CODE> - the subsequent timeout value type (ignored)<DT><B>Parameters:</B><DD><CODE>firstTimeoutSelector</CODE> - a function that returns an Observable that determines the timeout window for the first source
            item<DD><CODE>timeoutSelector</CODE> - a function that returns an Observable for each item emitted by the source Observable and that
            determines the timeout window in which the subsequent source item must arrive in order to
            continue the sequence
<DT><B>Returns:</B><DD>an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
         either the first item or any subsequent item doesn't arrive within the time windows specified by
         the timeout selectors</DL>
</DD>
</DL>
<HR>

<A NAME="timeout(rx.functions.Func0, rx.functions.Func1, rx.Observable)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final &lt;U,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&gt;&nbsp;firstTimeoutSelector,
                                         <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector,
                                         <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, but switches to a fallback Observable if either
 the first item emitted by the source Observable or any subsequent item don't arrive within time windows
 defined by other Observables.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout6.png">
 <p>
 This version of <code>timeout</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the first timeout value type (ignored)<DD><CODE>V</CODE> - the subsequent timeout value type (ignored)<DT><B>Parameters:</B><DD><CODE>firstTimeoutSelector</CODE> - a function that returns an Observable which determines the timeout window for the first source
            item<DD><CODE>timeoutSelector</CODE> - a function that returns an Observable for each item emitted by the source Observable and that
            determines the timeout window in which the subsequent source item must arrive in order to
            continue the sequence<DD><CODE>other</CODE> - the fallback Observable to switch to if the source Observable times out
<DT><B>Returns:</B><DD>an Observable that mirrors the source Observable, but switches to the <code>other</code> Observable if
         either the first item emitted by the source Observable or any subsequent item don't arrive within
         time windows defined by the timeout selectors
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>timeoutSelector</code> is null</DL>
</DD>
</DL>
<HR>

<A NAME="timeout(rx.functions.Func1)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final &lt;V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
 an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
 previous item, where that period of time is measured by an Observable that is a function of the previous
 item.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout3.png">
 <p>
 Note: The arrival of the first source item is never timed out.
 <p>
 This version of <code>timeout</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>V</CODE> - the timeout value type (ignored)<DT><B>Parameters:</B><DD><CODE>timeoutSelector</CODE> - a function that returns an observable for each item emitted by the source
            Observable and that determines the timeout window for the subsequent item
<DT><B>Returns:</B><DD>an Observable that mirrors the source Observable, but notifies observers of a TimeoutException if
         an item emitted by the source Observable takes longer to arrive than the time window defined by
         the selector for the previously emitted item</DL>
</DD>
</DL>
<HR>

<A NAME="timeout(rx.functions.Func1, rx.Observable)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final &lt;V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;V&gt;&gt;&nbsp;timeoutSelector,
                                       <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable, but that switches to a fallback Observable if
 an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
 previous item, where that period of time is measured by an Observable that is a function of the previous
 item.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout4.png">
 <p>
 Note: The arrival of the first source item is never timed out.
 <p>
 This version of <code>timeout</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>V</CODE> - the timeout value type (ignored)<DT><B>Parameters:</B><DD><CODE>timeoutSelector</CODE> - a function that returns an Observable, for each item emitted by the source Observable, that
            determines the timeout window for the subsequent item<DD><CODE>other</CODE> - the fallback Observable to switch to if the source Observable times out
<DT><B>Returns:</B><DD>an Observable that mirrors the source Observable, but switches to mirroring a fallback Observable
         if an item emitted by the source Observable takes longer to arrive than the time window defined
         by the selector for the previously emitted item</DL>
</DD>
</DL>
<HR>

<A NAME="timeout(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(long&nbsp;timeout,
                                   java.util.concurrent.TimeUnit&nbsp;timeUnit)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
 the resulting Observable terminates and notifies observers of a <code>TimeoutException</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.1.png">
 <p>
 This version of <code>timeout</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - maximum duration between emitted items before a timeout occurs<DD><CODE>timeUnit</CODE> - the unit of time that applies to the <code>timeout</code> argument.
<DT><B>Returns:</B><DD>the source Observable modified to notify observers of a <code>TimeoutException</code> in case of a
         timeout<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#timeout">RxJava Wiki: timeout()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh244283.aspx">MSDN: Observable.Timeout</a></DL>
</DD>
</DL>
<HR>

<A NAME="timeout(long, java.util.concurrent.TimeUnit, rx.Observable)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(long&nbsp;timeout,
                                   java.util.concurrent.TimeUnit&nbsp;timeUnit,
                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
 the resulting Observable begins instead to mirror a fallback Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.2.png">
 <p>
 This version of <code>timeout</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - maximum duration between items before a timeout occurs<DD><CODE>timeUnit</CODE> - the unit of time that applies to the <code>timeout</code> argument<DD><CODE>other</CODE> - the fallback Observable to use in case of a timeout
<DT><B>Returns:</B><DD>the source Observable modified to switch to the fallback Observable in case of a timeout<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#timeout">RxJava Wiki: timeout()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229512.aspx">MSDN: Observable.Timeout</a></DL>
</DD>
</DL>
<HR>

<A NAME="timeout(long, java.util.concurrent.TimeUnit, rx.Observable, rx.Scheduler)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(long&nbsp;timeout,
                                   java.util.concurrent.TimeUnit&nbsp;timeUnit,
                                   <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;other,
                                   <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration
 starting from its predecessor, the resulting Observable begins instead to mirror a fallback Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.2s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - maximum duration between items before a timeout occurs<DD><CODE>timeUnit</CODE> - the unit of time that applies to the <code>timeout</code> argument<DD><CODE>other</CODE> - the Observable to use as the fallback in case of a timeout<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to run the timeout timers on
<DT><B>Returns:</B><DD>the source Observable modified so that it will switch to the fallback Observable in case of a
         timeout<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#timeout">RxJava Wiki: timeout()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh211676.aspx">MSDN: Observable.Timeout</a></DL>
</DD>
</DL>
<HR>

<A NAME="timeout(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
timeout</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>timeout</B>(long&nbsp;timeout,
                                   java.util.concurrent.TimeUnit&nbsp;timeUnit,
                                   <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
 item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the
 specified timeout duration starting from its predecessor, the resulting Observable terminates and
 notifies observers of a <code>TimeoutException</code>.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.1s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - maximum duration between items before a timeout occurs<DD><CODE>timeUnit</CODE> - the unit of time that applies to the <code>timeout</code> argument<DD><CODE>scheduler</CODE> - the Scheduler to run the timeout timers on
<DT><B>Returns:</B><DD>the source Observable modified to notify observers of a <code>TimeoutException</code> in case of a
         timeout<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#timeout">RxJava Wiki: timeout()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh228946.aspx">MSDN: Observable.Timeout</a></DL>
</DD>
</DL>
<HR>

<A NAME="timestamp()"><!-- --></A><H3>
timestamp</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers">Timestamped</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>timestamp</B>()</PRE>
<DL>
<DD>Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers"><CODE>Timestamped</CODE></A> object.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.png">
 <p>
 <code>timestamp</code> operates by default on the <code>immediate</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits timestamped items from the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#timestamp">RxJava Wiki: timestamp()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229003.aspx">MSDN: Observable.Timestamp</a></DL>
</DD>
</DL>
<HR>

<A NAME="timestamp(rx.Scheduler)"><!-- --></A><H3>
timestamp</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers">Timestamped</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>timestamp</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits each item emitted by the source Observable, wrapped in a
 <A HREF="../rx/schedulers/Timestamped.html" title="class in rx.schedulers"><CODE>Timestamped</CODE></A> object whose timestamps are provided by a specified Scheduler.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use as a time source
<DT><B>Returns:</B><DD>an Observable that emits timestamped items from the source Observable with timestamps provided by
         the <code>scheduler</code><DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#timestamp">RxJava Wiki: timestamp()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229003.aspx">MSDN: Observable.Timestamp</a></DL>
</DD>
</DL>
<HR>

<A NAME="toBlockingObservable()"><!-- --></A><H3>
toBlockingObservable</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public final <A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables">BlockingObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>toBlockingObservable</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use <A HREF="../rx/Observable.html#toBlocking()"><CODE>Observable.toBlocking()</CODE></A> instead.</I>
<P>
<DD>Converts an Observable into a <A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables"><CODE>BlockingObservable</CODE></A> (an Observable with blocking operators).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>BlockingObservable</code> version of this Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">RxJava Wiki: Blocking Observable Observers</a></DL>
</DD>
</DL>
<HR>

<A NAME="toBlocking()"><!-- --></A><H3>
toBlocking</H3>
<PRE>
public final <A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables">BlockingObservable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>toBlocking</B>()</PRE>
<DL>
<DD>Converts an Observable into a <A HREF="../rx/observables/BlockingObservable.html" title="class in rx.observables"><CODE>BlockingObservable</CODE></A> (an Observable with blocking operators).
 <p>
 <code>toBlocking</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>BlockingObservable</code> version of this Observable<DT><B>Since:</B></DT>
  <DD>0.19</DD>
<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">RxJava Wiki: Blocking Observable Observers</a></DL>
</DD>
</DL>
<HR>

<A NAME="toList()"><!-- --></A><H3>
toList</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toList</B>()</PRE>
<DL>
<DD>Returns an Observable that emits a single item, a list composed of all the items emitted by the source
 Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toList.png">
 <p>
 Normally, an Observable that returns multiple items will do so by invoking its <A HREF="../rx/Observer.html" title="interface in rx"><CODE>Observer</CODE></A>'s
 <A HREF="../rx/Observer.html#onNext(T)"><CODE>onNext</CODE></A> method for each such item. You can change this behavior, instructing the
 Observable to compose a list of all of these items and then to invoke the Observer's <code>onNext</code>
 function once, passing it the entire list, by calling the Observable's <code>toList</code> method prior to
 calling its <A HREF="../rx/Observable.html#subscribe()"><CODE>Observable.subscribe()</CODE></A> method.
 <p>
 Be careful not to use this operator on Observables that emit infinite or very large numbers of items, as
 you do not have the option to unsubscribe.
 <p>
 <code>toList</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a single item: a List containing all of the items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tolist">RxJava Wiki: toList()</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMap(rx.functions.Func1)"><!-- --></A><H3>
toMap</H3>
<PRE>
public final &lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</PRE>
<DL>
<DD>Returns an Observable that emits a single HashMap containing all items emitted by the source Observable,
 mapped by the keys returned by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png">
 <p>
 If more than one source item maps to the same key, the HashMap will contain the latest of those items.
 <p>
 <code>toMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts the key from a source item to be used in the HashMap
<DT><B>Returns:</B><DD>an Observable that emits a single item: a HashMap containing the mapped items from the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229137.aspx">MSDN: Observable.ToDictionary</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMap(rx.functions.Func1, rx.functions.Func1)"><!-- --></A><H3>
toMap</H3>
<PRE>
public final &lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,V&gt;&gt; <B>toMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
                                                        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector)</PRE>
<DL>
<DD>Returns an Observable that emits a single HashMap containing values corresponding to items emitted by the
 source Observable, mapped by the keys returned by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png">
 <p>
 If more than one source item maps to the same key, the HashMap will contain a single entry that
 corresponds to the latest of those items.
 <p>
 <code>toMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts the key from a source item to be used in the HashMap<DD><CODE>valueSelector</CODE> - the function that extracts the value from a source item to be used in the HashMap
<DT><B>Returns:</B><DD>an Observable that emits a single item: a HashMap containing the mapped items from the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212075.aspx">MSDN: Observable.ToDictionary</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)"><!-- --></A><H3>
toMap</H3>
<PRE>
public final &lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,V&gt;&gt; <B>toMap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
                                                        <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
                                                        <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,V&gt;&gt;&nbsp;mapFactory)</PRE>
<DL>
<DD>Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains keys and values extracted from the items emitted by the source Observable.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png">
 <p>
 <code>toMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts the key from a source item to be used in the Map<DD><CODE>valueSelector</CODE> - the function that extracts the value from the source items to be used as value in the Map<DD><CODE>mapFactory</CODE> - the function that returns a Map instance to be used
<DT><B>Returns:</B><DD>an Observable that emits a single item: a Map that contains the mapped items emitted by the
         source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMultimap(rx.functions.Func1)"><!-- --></A><H3>
toMultimap</H3>
<PRE>
public final &lt;K&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&gt; <B>toMultimap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector)</PRE>
<DL>
<DD>Returns an Observable that emits a single HashMap that contains an ArrayList of items emitted by the
 source Observable keyed by a specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMultiMap.png">
 <p>
 <code>toMultiMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts the key from the source items to be used as key in the HashMap
<DT><B>Returns:</B><DD>an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
         the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh212098.aspx">MSDN: Observable.ToLookup</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMultimap(rx.functions.Func1, rx.functions.Func1)"><!-- --></A><H3>
toMultimap</H3>
<PRE>
public final &lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt; <B>toMultimap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
                                                                                   <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector)</PRE>
<DL>
<DD>Returns an Observable that emits a single HashMap that contains an ArrayList of values extracted by a
 specified <code>valueSelector</code> function from items emitted by the source Observable, keyed by a
 specified <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMultiMap.png">
 <p>
 <code>toMultiMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts a key from the source items to be used as key in the HashMap<DD><CODE>valueSelector</CODE> - the function that extracts a value from the source items to be used as value in the HashMap
<DT><B>Returns:</B><DD>an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
         the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a>, 
<a href="http://msdn.microsoft.com/en-us/library/hh229101.aspx">MSDN: Observable.ToLookup</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)"><!-- --></A><H3>
toMultimap</H3>
<PRE>
public final &lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt; <B>toMultimap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
                                                                                   <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
                                                                                   <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapFactory)</PRE>
<DL>
<DD>Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains an ArrayList of values, extracted by a specified <code>valueSelector</code> function from items
 emitted by the source Observable and keyed by the <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMultiMap.png">
 <p>
 <code>toMultiMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts a key from the source items to be used as the key in the Map<DD><CODE>valueSelector</CODE> - the function that extracts a value from the source items to be used as the value in the Map<DD><CODE>mapFactory</CODE> - the function that returns a Map instance to be used
<DT><B>Returns:</B><DD>an Observable that emits a single item: a Map that contains a list items mapped from the source
         Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a></DL>
</DD>
</DL>
<HR>

<A NAME="toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0, rx.functions.Func1)"><!-- --></A><H3>
toMultimap</H3>
<PRE>
public final &lt;K,V&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt; <B>toMultimap</B>(<A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends K&gt;&nbsp;keySelector,
                                                                                   <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? extends V&gt;&nbsp;valueSelector,
                                                                                   <A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapFactory,
                                                                                   <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super K,? extends java.util.Collection&lt;V&gt;&gt;&nbsp;collectionFactory)</PRE>
<DL>
<DD>Returns an Observable that emits a single Map, returned by a specified <code>mapFactory</code> function, that
 contains a custom collection of values, extracted by a specified <code>valueSelector</code> function from
 items emitted by the source Observable, and keyed by the <code>keySelector</code> function.
 <p>
 <img width="640" height="305" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMultiMap.png">
 <p>
 <code>toMultiMap</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keySelector</CODE> - the function that extracts a key from the source items to be used as the key in the Map<DD><CODE>valueSelector</CODE> - the function that extracts a value from the source items to be used as the value in the Map<DD><CODE>mapFactory</CODE> - the function that returns a Map instance to be used<DD><CODE>collectionFactory</CODE> - the function that returns a Collection instance for a particular key to be used in the Map
<DT><B>Returns:</B><DD>an Observable that emits a single item: a Map that contains the collection of mapped items from
         the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap">RxJava Wiki: toMap()</a></DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList()"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toSortedList</B>()</PRE>
<DL>
<DD>Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order. Each item emitted by the Observable must implement <CODE>Comparable</CODE> with respect to all
 other items in the sequence.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toSortedList.png">
 <p>
 <code>toSortedList</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an Observable that emits a list that contains the items emitted by the source Observable in
         sorted order
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if any item emitted by the Observable does not implement <CODE>Comparable</CODE> with respect to
             all other items emitted by the Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tosortedlist">RxJava Wiki: toSortedList()</a></DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(rx.functions.Func2)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toSortedList</B>(<A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer&gt;&nbsp;sortFunction)</PRE>
<DL>
<DD>Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
 sorted order based on a specified comparison function.
 <p>
 <img width="640" height="310" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toSortedList.f.png">
 <p>
 <code>toSortedList</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sortFunction</CODE> - a function that compares two items emitted by the source Observable and returns an Integer
            that indicates their sort order
<DT><B>Returns:</B><DD>an Observable that emits a list that contains the items emitted by the source Observable in
         sorted order<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tosortedlist">RxJava Wiki: toSortedList()</a></DL>
</DD>
</DL>
<HR>

<A NAME="unsubscribeOn(rx.Scheduler)"><!-- --></A><H3>
unsubscribeOn</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>unsubscribeOn</B>(<A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Modifies the source Observable so that subscribers will unsubscribe from it on a specified
 <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to perform unsubscription actions on
<DT><B>Returns:</B><DD>the source Observable modified so that its unsubscriptions happen on the specified
         <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A><DT><B>Since:</B></DT>
  <DD>0.17</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="window(rx.functions.Func0)"><!-- --></A><H3>
window</H3>
<PRE>
public final &lt;TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(<A HREF="../rx/functions/Func0.html" title="interface in rx.functions">Func0</A>&lt;? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;closingSelector)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows. It emits the current window and opens a new one
 whenever the Observable produced by the specified <code>closingSelector</code> emits an item.
 <p>
 <img width="640" height="485" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window1.png">
 <p>
 This version of <code>window</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>closingSelector</CODE> - a <A HREF="../rx/functions/Func0.html" title="interface in rx.functions"><CODE>Func0</CODE></A> that returns an <code>Observable</code> that governs the boundary between windows.
            When this <code>Observable</code> emits an item, <code>window</code> emits the current window and begins
            a new one.
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows of items from the source Observable
         whenever <code>closingSelector</code> emits an item<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(int)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows, each containing <code>count</code> items. When the source
 Observable completes or encounters an error, the resulting Observable emits the current window and
 propagates the notification from the source Observable.
 <p>
 <img width="640" height="400" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window3.png">
 <p>
 This version of <code>window</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum size of each window before it should be emitted
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows, each containing at most
         <code>count</code> items from the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(int, int)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(int&nbsp;count,
                                              int&nbsp;skip)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits windows every <code>skip</code> items, each containing no more than <code>count</code> items. When
 the source Observable completes or encounters an error, the resulting Observable emits the current window
 and propagates the notification from the source Observable.
 <p>
 <img width="640" height="365" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window4.png">
 <p>
 This version of <code>window</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>count</CODE> - the maximum size of each window before it should be emitted<DD><CODE>skip</CODE> - how many items need to be skipped before starting a new window. Note that if <code>skip</code> and
            <code>count</code> are equal this is the same operation as <A HREF="../rx/Observable.html#window(int)"><CODE>Observable.window(int)</CODE></A>.
<DT><B>Returns:</B><DD>an Observable that emits windows every <code>skip</code> items containing at most <code>count</code> items
         from the source Observable<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              long&nbsp;timeshift,
                                              java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable starts a new window periodically, as determined by the <code>timeshift</code> argument. It emits
 each window after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window7.png">
 <p>
 This version of <code>window</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted<DD><CODE>timeshift</CODE> - the period of time after which a new window will be created<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments
<DT><B>Returns:</B><DD>an Observable that emits new windows periodically as a fixed timespan elapses<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              long&nbsp;timeshift,
                                              java.util.concurrent.TimeUnit&nbsp;unit,
                                              <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable starts a new window periodically, as determined by the <code>timeshift</code> argument. It emits
 each window after a fixed timespan, specified by the <code>timespan</code> argument. When the source
 Observable completes or Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="335" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window7.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted<DD><CODE>timeshift</CODE> - the period of time after which a new window will be created<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> and <code>timeshift</code> arguments<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a window
<DT><B>Returns:</B><DD>an Observable that emits new windows periodically as a fixed timespan elapses<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window5.png">
 <p>
 This version of <code>window</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted and replaced with a
            new window<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> argument
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows represending items emitted by the
         source Observable during fixed, consecutive durations<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, java.util.concurrent.TimeUnit, int)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              java.util.concurrent.TimeUnit&nbsp;unit,
                                              int&nbsp;count)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
 <code>timespan</code> argument or a maximum size as specified by the <code>count</code> argument (whichever is
 reached first). When the source Observable completes or encounters an error, the resulting Observable
 emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window6.png">
 <p>
 This version of <code>window</code> operates by default on the <code>computation</code> <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted and replaced with a
            new window<DD><CODE>unit</CODE> - the unit of time that applies to the <code>timespan</code> argument<DD><CODE>count</CODE> - the maximum size of each window before it should be emitted
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows of items from the source Observable
         that were emitted during a fixed duration of time or when the window has reached maximum capacity
         (whichever occurs first)<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              java.util.concurrent.TimeUnit&nbsp;unit,
                                              int&nbsp;count,
                                              <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
 <code>timespan</code> argument or a maximum size specified by the <code>count</code> argument (whichever is reached
 first). When the source Observable completes or encounters an error, the resulting Observable emits the
 current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="370" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window6.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted and replaced with a
            new window<DD><CODE>unit</CODE> - the unit of time which applies to the <code>timespan</code> argument<DD><CODE>count</CODE> - the maximum size of each window before it should be emitted<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a window
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows of items from the source Observable
         that were emitted during a fixed duration of time or when the window has reached maximum capacity
         (whichever occurs first)<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><!-- --></A><H3>
window</H3>
<PRE>
public final <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(long&nbsp;timespan,
                                              java.util.concurrent.TimeUnit&nbsp;unit,
                                              <A HREF="../rx/Scheduler.html" title="class in rx">Scheduler</A>&nbsp;scheduler)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
 <code>timespan</code> argument. When the source Observable completes or encounters an error, the resulting
 Observable emits the current window and propagates the notification from the source Observable.
 <p>
 <img width="640" height="375" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window5.s.png">
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timespan</CODE> - the period of time each window collects items before it should be emitted and replaced with a
            new window<DD><CODE>unit</CODE> - the unit of time which applies to the <code>timespan</code> argument<DD><CODE>scheduler</CODE> - the <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A> to use when determining the end and start of a window
<DT><B>Returns:</B><DD>an Observable that emits connected, non-overlapping windows containing items emitted by the
         source Observable within a fixed duration<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(rx.Observable, rx.functions.Func1)"><!-- --></A><H3>
window</H3>
<PRE>
public final &lt;TOpening,TClosing&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TOpening&gt;&nbsp;windowOpenings,
                                                                  <A HREF="../rx/functions/Func1.html" title="interface in rx.functions">Func1</A>&lt;? super TOpening,? extends <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends TClosing&gt;&gt;&nbsp;closingSelector)</PRE>
<DL>
<DD>Returns an Observable that emits windows of items it collects from the source Observable. The resulting
 Observable emits windows that contain those items emitted by the source Observable between the time when
 the <code>windowOpenings</code> Observable emits an item and when the Observable returned by
 <code>closingSelector</code> emits an item.
 <p>
 <img width="640" height="550" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window2.png">
 <p>
 This version of <code>window</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>windowOpenings</CODE> - an Observable that, when it emits an item, causes another window to be created<DD><CODE>closingSelector</CODE> - a <A HREF="../rx/functions/Func1.html" title="interface in rx.functions"><CODE>Func1</CODE></A> that produces an Observable for every window created. When this Observable
            emits an item, the associated window is closed and emitted
<DT><B>Returns:</B><DD>an Observable that emits windows of items emitted by the source Observable that are governed by
         the specified window-governing Observables<DT><B>See Also:</B><DD><a href="https://github.com/Netflix/RxJava/wiki/Transforming-Observables#window">RxJava Wiki: window()</a></DL>
</DD>
</DL>
<HR>

<A NAME="window(rx.Observable)"><!-- --></A><H3>
window</H3>
<PRE>
public final &lt;U&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>window</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;U&gt;&nbsp;boundary)</PRE>
<DL>
<DD>Returns an Observable that emits non-overlapping windows of items it collects from the source Observable
 where the boundary of each window is determined by the items emitted from a specified boundary-governing
 Observable.
 <p>
 <img width="640" height="475" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/window8.png">
 <p>
 This version of <code>window</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>U</CODE> - the window element type (ignored)<DT><B>Parameters:</B><DD><CODE>boundary</CODE> - an Observable whose emitted items close and open windows
<DT><B>Returns:</B><DD>an Observable that emits non-overlapping windows of items it collects from the source Observable
         where the boundary of each window is determined by the items emitted from the <code>boundary</code>
         Observable</DL>
</DD>
</DL>
<HR>

<A NAME="zip(java.lang.Iterable, rx.functions.Func2)"><!-- --></A><H3>
zip</H3>
<PRE>
public final &lt;T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(java.lang.Iterable&lt;? extends T2&gt;&nbsp;other,
                                      <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super T2,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and a specified Iterable sequence.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.i.png">
 <p>
 Note that the <code>other</code> Iterable is evaluated as items are observed from the source Observable; it is
 not pre-consumed. This allows you to zip infinite streams on either side.
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T2</CODE> - the type of items in the <code>other</code> Iterable<DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>other</CODE> - the Iterable sequence<DD><CODE>zipFunction</CODE> - a function that combines the pairs of items from the Observable and the Iterable to generate
            the items to be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that pairs up values from the source Observable and the <code>other</code> Iterable
         sequence and emits the results of <code>zipFunction</code> applied to these pairs</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.functions.Func2)"><!-- --></A><H3>
zip</H3>
<PRE>
public final &lt;T2,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;? extends T2&gt;&nbsp;other,
                                      <A HREF="../rx/functions/Func2.html" title="interface in rx.functions">Func2</A>&lt;? super <A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,? super T2,? extends R&gt;&nbsp;zipFunction)</PRE>
<DL>
<DD>Returns an Observable that emits items that are the result of applying a specified function to pairs of
 values, one each from the source Observable and another specified Observable.
 <p>
 <img width="640" height="380" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">
 <p>
 <code>zip</code> does not operate by default on a particular <A HREF="../rx/Scheduler.html" title="class in rx"><CODE>Scheduler</CODE></A>.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T2</CODE> - the type of items emitted by the <code>other</code> Observable<DD><CODE>R</CODE> - the type of items emitted by the resulting Observable<DT><B>Parameters:</B><DD><CODE>other</CODE> - the other Observable<DD><CODE>zipFunction</CODE> - a function that combines the pairs of items from the two Observables to generate the items to
            be emitted by the resulting Observable
<DT><B>Returns:</B><DD>an Observable that pairs up values from the source Observable and the <code>other</code> Observable
         and emits the results of <code>zipFunction</code> applied to these pairs</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../rx/Notification.Kind.html" title="enum in rx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../rx/Observable.OnSubscribe.html" title="interface in rx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?rx/Observable.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Observable.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
